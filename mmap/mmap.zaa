//
// mmap
//

import std.stdlib : assert;
import std.span;
import std.string : String;
import std.error;

enum mode
{
  readonly = 0x0,
  readwrite = 0x01,
}

pub struct mmap_error_category : pub std::error_category
{
  fn instance() -> mmap_error_category *
  {
    static instance = #mmap_error_category::mmap_error_category();

    return &instance;
  }

  pub fn message(uintptr value, u8 mut *buffer, usize buflen) -> std::string_view
  {
    return strerror(value, buffer, buflen);
  }

  mmap_error_category() = default;
  mmap_error_category(mmap_error_category &) = default;
  ~mmap_error_category() = default;
}

pub fn error_category() -> mmap_error_category *
{
  return mmap_error_category::instance;
}

pub fn mmap_error(uintptr code) -> std::error
{
  var result = std::error(void);

  result.value = code;
  result.category = mmap_error_category::instance;

  return result;
}

pub struct file
{
  pub fn open(String &path, u64 offset = 0, usize length = 0) throws -> file
  {
    var fd = open_file(std::string_view(path.data, path.len), mode::readonly);

    var addr = map_file(fd, offset, &mut length, mode::readonly);

    close_file(fd);

    return file(addr, length);
  }

  pub fn map(std::fd &fd, u64 offset = 0, usize length = 0) throws -> file
  {
    var addr = map_file(cast(std::bit_cast<uintptr>(fd)), offset, &mut length, mode::readonly);

    return file(addr, length);
  }

  pub file(u8 *data, usize len)
    : _data(data), _len(len)
  {
  }

  pub ~file()
  {
    unmap(_data, _len);
  }

  pub fn len(this &) -> usize
  {
    return this._len;
  }

  pub fn size(this &) -> usize
  {
    return this._len;
  }

  pub fn data(this &) -> u8 *
  {
    return this._data;
  }

  pub fn begin(this &) -> u8 *
  {
    return this._data;
  }

  pub fn end(this &) -> u8 *
  {
    return this._data + this._len;
  }

  pub fn [](this &, usize index) -> u8 &
  {
    assert(index < this._len);

    return &*(this._data + index);
  }

  pub fn [](this &, (usize, usize) range) -> std::span<u8>
  {
    assert(range.0 <= range.1 && range.0 < this._len && range.1 <= this._len);

    return std::span(this._data + range.0, this._data + range.1);
  }

  pub fn [](this &, (usize, usize, void) range) -> std::span<u8>
  {
    assert(range.0 <= range.1 && range.0 < this._len && range.1 + 1 <= this._len);

    return std::span(this._data + range.0, this._data + range.1 + 1);
  }

  usize _len;
  u8 *_data;
}

pub struct mutable_file
{
  pub fn open(String &path, u64 offset = 0, usize length = 0) throws -> mutable_file
  {
    var fd = open_file(std::string_view(path.data, path.len), mode::readwrite);

    var addr = map_file(fd, offset, &mut length, mode::readwrite);

    close_file(fd);

    return mutable_file(addr, length);
  }

  pub fn map(std::fd &fd, u64 offset = 0, usize length = 0) throws -> mutable_file
  {
    var addr = map_file(cast(std::bit_cast<uintptr>(fd)), offset, &mut length, mode::readwrite);

    return mutable_file(addr, length);
  }

  pub mutable_file(u8 mut *data, usize len)
    : _data(data), _len(len)
  {
  }

  pub ~mutable_file()
  {
    unmap(_data, _len);
  }

  pub fn len(this &) -> usize
  {
    return this._len;
  }

  pub fn size(this &) -> usize
  {
    return this._len;
  }

  pub fn data(this &&)
  {
    return this._data;
  }

  pub fn begin(this &&)
  {
    return this._data;
  }

  pub fn end(this &&)
  {
    return this._data + this._len;
  }

  pub fn [](this &&, usize index)
  {
    assert(index < this._len);

    return &*(this._data + index);
  }

  pub fn [](this &, (usize, usize) range) -> std::span<u8>
  {
    assert(range.0 <= range.1 && range.0 < this._len && range.1 <= this._len);

    return std::span(this._data + range.0, this._data + range.1);
  }

  pub fn [](this &, (usize, usize, void) range) -> std::span<u8>
  {
    assert(range.0 <= range.1 && range.0 < this._len && range.1 + 1 <= this._len);

    return std::span(this._data + range.0, this._data + range.1 + 1);
  }

  pub fn [](this mut &, (usize, usize) range) -> std::mutable_span<u8>
  {
    assert(range.0 <= range.1 && range.0 < this._len && range.1 <= this._len);

    return std::mutable_span(this._data + range.0, this._data + range.1);
  }

  pub fn [](this mut &, (usize, usize, void) range) -> std::mutable_span<u8>
  {
    assert(range.0 <= range.1 && range.0 < this._len && range.1 + 1 <= this._len);

    return std::mutable_span(this._data + range.0, this._data + range.1 + 1);
  }

  usize _len;
  u8 mut *_data;
}

#if __cfg("os.linux")

  import os.linux.mman : *;
  import os.linux.fcntl : *;

  fn strerror(uintptr value, u8 mut *buffer, usize buflen) -> std::string_view
  {
    return std::meta::enumerator_name(cast<std::errc>(value));
  }

  fn open_file(std::string_view path, mode mode) throws -> int
  {
    var pathstr = [0; 2048];

    if (path.len >= pathstr.len)
      throw mmap_error(36);

    std::memcpy(pathstr.data, path.data, path.len);

    var fd = open(pathstr.data, (mode == mode::readonly) ? O_RDONLY : O_RDWR, 0o666);

    if (fd < 0)
      throw mmap_error(cast<uintptr>(-fd));

    return fd;
  }

  fn map_file(int fd, u64 offset, usize mut &length, mode mode) throws -> u8 mut *
  {
    if (length == 0)
    {
      var fs = stat();
      if (var result = fstat(fd, &fs); result < 0)
      {
        close(fd);

        throw mmap_error(cast<uintptr>(-result));
      }

      length = cast<usize>(fs.st_size - offset);
    }

    var addr = mmap(null, length, (mode == mode::readonly) ? PROT_READ : PROT_WRITE, MAP_SHARED, fd, offset);

    if (var result = std::bit_cast<intptr>(addr); result < 0)
    {
      close(fd);

      throw mmap_error(cast<uintptr>(-result));
    }

    return cast<u8 mut *>(addr);
  }

  fn unmap(void *addr, usize length) -> void
  {
    munmap(addr, length);
  }

  fn close_file(int fd) -> void
  {
    close(fd);
  }

#end

#if __cfg("os.windows")

  import os.windows.kernel32 : *;

  fn strerror(uintptr value, u8 mut *buffer, usize buflen) -> std::string_view
  {
    var nchars = FormatMessageA(0x00001000, null, cast(value), 0x400, buffer, cast(buflen), null);

    return std::string_view(buffer, cast<usize>(nchars)).trim_right;
  }

  fn open_file(std::string_view path, mode mode) throws -> HANDLE
  {
    var pathstr = [0; 2048];

    var nchars = MultiByteToWideChar(CP_UTF8, 0, path.data, cast(path.len), pathstr.data, cast(pathstr.len));

    if (nchars == 0)
      throw mmap_error(cast<uintptr>(GetLastError()));

    var access = (mode == mode::readonly) ? GENERIC_READ : GENERIC_READ | GENERIC_WRITE;

    var handle = CreateFileW(pathstr.data, access, FILE_SHARE_READ | FILE_SHARE_WRITE, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (handle == INVALID_HANDLE_VALUE)
      throw mmap_error(cast<uintptr>(GetLastError()));

    return handle;
  }

  fn map_file(HANDLE fd, u64 offset, usize mut &length, mode mode) throws -> u8 mut *
  {
    if (length == 0)
    {
      var size = 0;
      if (GetFileSizeEx(fd, &size) == 0)
      {
        CloseHandle(fd);

        throw mmap_error(cast<uintptr>(GetLastError()));
      }

      length = cast<usize>(cast<u64>(size) - offset);
    }

    var sizelo = cast<u32>(length & 0xffffffff);
    var sizehi = cast<u32>(length >> 32);

    var offsetlo = cast<u32>(offset & 0xffffffff);
    var offsethi = cast<u32>(offset >> 32);

    var protect = (mode == mode::readonly) ? PAGE_READONLY : PAGE_READWRITE;

    var filemap = CreateFileMappingW(fd, null, protect, sizehi, sizelo, null);

    if (filemap == INVALID_HANDLE_VALUE)
    {
      CloseHandle(fd);

      throw mmap_error(cast<uintptr>(GetLastError()));
    }

    var access = (mode == mode::readonly) ? FILE_MAP_READ : FILE_MAP_READ | FILE_MAP_WRITE;

    var addr = MapViewOfFileEx(filemap, access, offsethi, offsetlo, length, null);

    if (!addr)
    {
      CloseHandle(fd);
      CloseHandle(filemap);

      throw mmap_error(cast<uintptr>(GetLastError()));
    }

    CloseHandle(filemap);

    return cast<u8 mut *>(addr);
  }

  fn unmap(void *addr, usize length) -> void
  {
    UnmapViewOfFileEx(addr, 0);
  }

  fn close_file(HANDLE fd) -> void
  {
    CloseHandle(fd);
  }

#end
