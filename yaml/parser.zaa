//
// yaml parser
//

import yaml;
import yaml.scanner;
import std.io : InputReader;
import std.vector;
import std.flat_map;
import std.scan;

using yaml::errc;
using yaml::mark;
using yaml::node;
using yaml::token;
using yaml::scanner;
using yaml::scalar_style;

enum state
{
  stream_start = 0,
  implicit_document_start,
  document_start,
  document_content,
  document_end,
  block_node,
  block_node_or_indentless_sequence,
  flow_node,
  block_sequence_entry,
  indentless_sequence_entry,
  block_mapping_key,
  block_mapping_value,
  flow_sequence_entry,
  flow_sequence_entry_mapping_key,
  flow_sequence_entry_mapping_value,
  flow_mapping_key,
  flow_mapping_value,
  sequence_entry,
  sequence_flow_entry,
  mapping_entry,
  mapping_flow_entry,
  anchor_entry,
  tag_seq,
  tag_map,
  tag_set,
  tag_str,
  tag_binary,
  tag_null,
  tag_bool,
  tag_int,
  tag_float,
  tag_unknown,
  end,
}

enum result : i32
{
  ok = 0,

  fn bool(this &) -> bool
  {
    return cast<i32>(this) >= 0;
  }

  result(errc error)
    : this(cast<result>(-cast<i32>(error)))
  {
  }
}

pub struct parse_result
{
  pub errc error;
  pub mark mark;
  pub std::vector<node> docs;

  pub fn bool(this &) -> bool
  {
    return !this.error;
  }

  pub parse_result() = default;
  pub parse_result(parse_result&) = default;
  pub fn =(parse_result mut &, parse_result&) -> parse_result mut & = default;
  pub ~parse_result() = default;
}

struct parse_context
{
  token tok;
  state state;
  scanner scanner;
  std::vector<node> stack;
  std::vector<state> states;
  std::flat_map<std::string, node> anchors;
  std::vector<std::string> names;

  fn push_state(this mut &, state state) -> void
  {
    this.states.push_back(state);
  }

  fn pop_state(this mut &) -> state
  {
    return this.states.take_back();
  }

  #[lifetime(launder(this.tok))]
  fn consume_token(this mut &, var mut &is) throws(std::error) -> void
  {
    this.tok = this.scanner.fetch(&mut is);
  }

  parse_context()
  {
    states.reserve(32);
  }

  ~parse_context() = default;
}

fn parse_process_directives(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  while (ctx.tok.type == token::type::directive)
  {
    ctx.consume_token(&mut is);
  }

  return ok;
}

fn stream_start(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  ctx.consume_token(&mut is);

  ctx.state = state::implicit_document_start;

  return ok;
}

fn document_start(parse_context mut &ctx, InputReader mut &is, bool implicit) throws(std::error) -> result
{
  if (!implicit)
  {
    while (ctx.tok.type == token::type::document_end)
      ctx.consume_token(&mut is);
  }

  switch (ctx.tok.type)
  {
    case stream_end:
      ctx.consume_token(&mut is);
      ctx.state = state::end;

    case directive:
      if (var rc = parse_process_directives(&mut ctx, &mut is); !rc)
        return rc;

    case document_start:
      ctx.consume_token(&mut is);
      ctx.push_state(state::document_end);
      ctx.state = state::document_content;

    else:
      if (!implicit)
        return errc::expected_document_start;

      if (var rc = parse_process_directives(&mut ctx, &mut is); !rc)
        return rc;

      ctx.push_state(state::document_end);
      ctx.state = state::block_node;
  }

  return ok;
}

fn document_content(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case directive:
    case document_start:
    case document_end:
    case stream_end:
      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;

    else:
      if (var rc = parse_node(&mut ctx, &mut is, true, false); !rc)
        return rc;
  }

  return ok;
}

fn document_end(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  if (ctx.tok.type == token::type::document_end)
    ctx.consume_token(&mut is);

  ctx.state = state::document_start;

  return ok;
}

fn parse_tag(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  if (ctx.tok.value == "!!seq")
    ctx.state = state::tag_seq;

  else if (ctx.tok.value == "!!map")
    ctx.state = state::tag_map;

  else if (ctx.tok.value == "!!set")
    ctx.state = state::tag_set;

  else if (ctx.tok.value == "!!str")
    ctx.state = state::tag_str;

  else if (ctx.tok.value == "!!binary")
    ctx.state = state::tag_binary;

  else if (ctx.tok.value == "!!null")
    ctx.state = state::tag_null;

  else if (ctx.tok.value == "!!bool")
    ctx.state = state::tag_bool;

  else if (ctx.tok.value == "!!int")
    ctx.state = state::tag_int;

  else if (ctx.tok.value == "!!float")
    ctx.state = state::tag_float;

  else
    ctx.state = state::tag_unknown;

  ctx.consume_token(&mut is);

  return ok;
}

fn parse_empty(parse_context mut &ctx, InputReader mut &is) -> result
{
  switch (ctx.state)
  {
    case tag_seq:
      ctx.stack.push_back(std::vector<node>());

    case tag_map:
    case tag_set:
      ctx.stack.push_back(std::flat_hash_map<node, node>());

    case tag_null:
      ctx.stack.push_back(null);

    case tag_bool:
      ctx.stack.push_back(false);

    case tag_int:
      ctx.stack.push_back(0);

    case tag_float:
      ctx.stack.push_back(0.0);

    case tag_str:
    case tag_binary:
      ctx.stack.push_back("");

    case tag_unknown:
      return errc::unknown_tag;

    else:
      ctx.stack.push_back(null);
  }

  ctx.state = ctx.pop_state();

  return ok;
}

fn parse_scalar(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.state)
  {
    case tag_null:
      if (ctx.tok.value != "~" && ctx.tok.value != "null")
        return errc::invalid_null_value;

      ctx.stack.push_back(null);

    case tag_bool:
      if (ctx.tok.value != "true" && ctx.tok.value != "false")
        return errc::invalid_bool_value;

      ctx.stack.push_back(ctx.tok.value == "true");

    case tag_int:
      var integer = i64();
      if (std::sscan(ctx.tok.value, &mut integer).len != ctx.tok.value.len)
        return errc::invalid_int_value;

      ctx.stack.push_back(integer);

    case tag_float:
      var real = f64();
      if (std::sscan(ctx.tok.value, &mut real).len != ctx.tok.value.len)
        return errc::invalid_float_value;

      ctx.stack.push_back(real);

    case tag_str:
    case tag_binary:
      ctx.stack.push_back(&move ctx.tok.value);

    case tag_unknown:
      return errc::unknown_tag;

    else:
      switch (ctx.tok.style)
      {
        case plain:
          ctx.stack.push_back(node::from(ctx.tok.value));

        else:
          ctx.stack.push_back(&move ctx.tok.value);
      }
  }

  ctx.consume_token(&mut is);
  ctx.state = ctx.pop_state();

  return ok;
}

fn parse_sequence(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case block_sequence_start:
      ctx.consume_token(&mut is);
      ctx.state = state::block_sequence_entry;

    case flow_sequence_start:
      ctx.consume_token(&mut is);
      ctx.state = state::flow_sequence_entry;

    case block_entry:
      ctx.state = state::indentless_sequence_entry;

    else:
      std::panic("unexpected");
  }

  ctx.stack.push_back(std::vector<node>());

  return ok;
}

fn sequence_entry(parse_context mut &ctx, InputReader mut &is) -> result
{
  var entry = ctx.stack.take_back();
  var mut &array = ctx.stack.back.Array;

  array.push_back(&move entry);

  ctx.state = ctx.pop_state();

  return ok;
}

fn parse_mapping(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case block_mapping_start:
      ctx.consume_token(&mut is);
      ctx.state = state::block_mapping_key;

    case flow_mapping_start:
      ctx.consume_token(&mut is);
      ctx.state = state::flow_mapping_key;

    case key:
      ctx.consume_token(&mut is);
      ctx.state = state::flow_sequence_entry_mapping_key;

    case value:
      ctx.state = state::flow_sequence_entry_mapping_key;

    else:
      std::panic("unexpected");
  }

  ctx.stack.push_back(std::flat_hash_map<node, node>());

  return ok;
}

fn mapping_entry(parse_context mut &ctx, InputReader mut &is) -> result
{
  var value = ctx.stack.take_back();
  var key = ctx.stack.take_back();
  var mut &map = ctx.stack.back.Map;

  map.insert(&move key, &move value);

  ctx.state = ctx.pop_state();

  return ok;
}

fn parse_node(parse_context mut &ctx, InputReader mut &is, bool block, bool indentless_sequence) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case tag:
      if (var rc = parse_tag(&mut ctx, &mut is); !rc)
        return rc;

      switch (ctx.tok.type)
      {
        case anchor:
          ctx.push_state(state::anchor_entry);
          ctx.names.push_back(&move ctx.tok.value);
          ctx.consume_token(&mut is);
      }

    case anchor:
      ctx.push_state(state::anchor_entry);
      ctx.names.push_back(&move ctx.tok.value);
      ctx.consume_token(&mut is);

      switch (ctx.tok.type)
      {
        case tag:
          if (var rc = parse_tag(&mut ctx, &mut is); !rc)
            return rc;
      }
  }

  switch (ctx.tok.type)
  {
    case alias:
      var j = ctx.anchors.find(ctx.tok.value);

      if (j == ctx.anchors.end)
        return errc::anchor_not_found;

      ctx.consume_token(&mut is);
      ctx.stack.push_back((*j).value);
      ctx.state = ctx.pop_state();

    case key:
    case value:
    case block_end:
    case flow_entry:
    case flow_sequence_end:
    case flow_mapping_end:
    case document_start:
    case document_end:
    case stream_end:
      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;

    case block_entry:
      if (!indentless_sequence)
      {
        if (var rc = parse_empty(&mut ctx, &mut is); !rc)
          return rc;
      }
      else
      {
        if (var rc = parse_sequence(&mut ctx, &mut is); !rc)
          return rc;
      }

    case block_sequence_start:
    case flow_sequence_start:

      if (ctx.tok.type == token::type::block_sequence_start && !block)
        return errc::invalid_sequence_start;

      if (var rc = parse_sequence(&mut ctx, &mut is); !rc)
        return rc;

    case block_mapping_start:
    case flow_mapping_start:

      if (ctx.tok.type == token::type::block_mapping_start && !block)
        return errc::invalid_mapping_start;

      if (var rc = parse_mapping(&mut ctx, &mut is); !rc)
        return rc;

    case scalar:
      if (var rc = parse_scalar(&mut ctx, &mut is); !rc)
        return rc;

    else:
      switch (ctx.tok.type)
      {
        case bad_escape:
          return errc::bad_escape;

        case bad_indent_character:
          return errc::bad_indent_character;

        case unexpected_document_indicator:
          return errc::unexpected_document_indicator;

        case unexpected_end_of_stream:
          return errc::unexpected_end_of_stream;

        case invalid_sequence_start:
          return errc::invalid_sequence_start;

        case invalid_mapping_start:
          return errc::invalid_mapping_start;

        else:
          return errc::invalid_value;
      }
  }

  return ok;
}

fn anchor_entry(parse_context mut &ctx, InputReader mut &is) -> result
{
  ctx.anchors.insert_or_assign(ctx.names.take_back(), ctx.stack.back());

  ctx.state = ctx.pop_state();

  return ok;
}

fn block_sequence_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case block_end:
      ctx.consume_token(&mut is);
      ctx.state = ctx.pop_state();

    case block_entry:
      ctx.consume_token(&mut is);
      ctx.push_state(state::block_sequence_entry);
      ctx.push_state(state::sequence_entry);

      if (var rc = parse_node(&mut ctx, &mut is, true, false); !rc)
        return rc;

    else:
      return errc::expected_sequence_entry;
  }

  return ok;
}

fn block_mapping_key(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case block_end:
      ctx.consume_token(&mut is);
      ctx.state = ctx.pop_state();

    case key:
      ctx.consume_token(&mut is);
      ctx.push_state(state::block_mapping_value);

      if (var rc = parse_node(&mut ctx, &mut is, true, true); !rc)
        return rc;

    case value:
      ctx.push_state(state::block_mapping_value);

      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;

    else:
      return errc::expected_block_mapping_key;
  }

  return ok;
}

fn block_mapping_value(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case value:
      ctx.consume_token(&mut is);
      ctx.push_state(state::block_mapping_key);
      ctx.push_state(state::mapping_entry);

      if (var rc = parse_node(&mut ctx, &mut is, true, true); !rc)
        return rc;

    else:
      ctx.push_state(state::block_mapping_key);
      ctx.push_state(state::mapping_entry);

      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;
  }

  return ok;
}

fn flow_sequence_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case flow_entry:
      return errc::expected_sequence_entry;

    case flow_sequence_end:
      ctx.consume_token(&mut is);
      ctx.state = ctx.pop_state();

    case key:
    case value:
      ctx.push_state(state::flow_sequence_entry);
      ctx.push_state(state::sequence_flow_entry);

      if (var rc = parse_mapping(&mut ctx, &mut is); !rc)
        return rc;

    else:
      ctx.push_state(state::flow_sequence_entry);
      ctx.push_state(state::sequence_flow_entry);

      if (var rc = parse_node(&mut ctx, &mut is, false, false); !rc)
        return rc;
  }

  return ok;
}

fn sequence_flow_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case flow_entry:
    case flow_sequence_end:
      if (var rc = sequence_entry(&mut ctx, &mut is); !rc)
        return rc;

      if (ctx.tok.type == token::type::flow_entry)
        ctx.consume_token(&mut is);

    else:
      return errc::expected_comma;
  }

  return ok;
}

fn flow_mapping_key(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case flow_mapping_end:
      ctx.consume_token(&mut is);
      ctx.state = ctx.pop_state();

    case key:
      ctx.consume_token(&mut is);
      ctx.push_state(state::flow_mapping_value);

      if (var rc = parse_node(&mut ctx, &mut is, false, false); !rc)
        return rc;

    case value:
      ctx.push_state(state::flow_mapping_value);

      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;

    else:
      ctx.push_state(state::flow_mapping_value);

      if (var rc = parse_node(&mut ctx, &mut is, false, false); !rc)
        return rc;
  }

  return ok;
}

fn flow_mapping_value(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case value:
      ctx.consume_token(&mut is);
      ctx.push_state(state::flow_mapping_key);
      ctx.push_state(state::mapping_flow_entry);

      if (var rc = parse_node(&mut ctx, &mut is, true, true); !rc)
        return rc;

    else:
      ctx.push_state(state::flow_mapping_key);
      ctx.push_state(state::mapping_flow_entry);

      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;
  }

  return ok;
}

fn mapping_flow_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case flow_entry:
    case flow_mapping_end:
      if (var rc = mapping_entry(&mut ctx, &mut is); !rc)
        return rc;

      if (ctx.tok.type == token::type::flow_entry)
        ctx.consume_token(&mut is);

    else:
      return errc::expected_comma;
  }

  return ok;
}

fn indentless_sequence_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case block_entry:
      ctx.consume_token(&mut is);
      ctx.push_state(state::indentless_sequence_entry);
      ctx.push_state(state::sequence_entry);

      if (var rc = parse_node(&mut ctx, &mut is, true, false); !rc)
        return rc;

    else:
      ctx.state = ctx.pop_state();
  }

  return ok;
}

fn flow_sequence_entry_mapping_key(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case value:
    case flow_entry:
    case flow_sequence_end:
      ctx.push_state(state::flow_sequence_entry_mapping_value);

      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;

    else:
      ctx.push_state(state::flow_sequence_entry_mapping_value);

      if (var rc = parse_node(&mut ctx, &mut is, false, false); !rc)
        return rc;
  }

  return ok;
}

fn flow_sequence_entry_mapping_value(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case value:
      ctx.consume_token(&mut is);
      ctx.push_state(state::mapping_entry);

      if (var rc = parse_node(&mut ctx, &mut is, false, false); !rc)
        return rc;

    else:
      ctx.push_state(state::mapping_entry);

      if (var rc = parse_empty(&mut ctx, &mut is); !rc)
        return rc;
  }

  return ok;
}

fn parse(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  ctx.consume_token(&mut is);

  while (ctx.state != state::end)
  {
    switch (ctx.state)
    {
      case stream_start:
        if (var rc = stream_start(&mut ctx, &mut is); !rc)
          return rc;

      case implicit_document_start:
        if (var rc = document_start(&mut ctx, &mut is, true); !rc)
          return rc;

      case document_start:
        if (var rc = document_start(&mut ctx, &mut is, false); !rc)
          return rc;

      case document_content:
        if (var rc = document_content(&mut ctx, &mut is); !rc)
          return rc;

      case document_end:
        if (var rc = document_end(&mut ctx, &mut is); !rc)
          return rc;

      case block_node:
        if (var rc = parse_node(&mut ctx, &mut is, true, false); !rc)
          return rc;

      case block_sequence_entry:
        if (var rc = block_sequence_entry(&mut ctx, &mut is); !rc)
          return rc;

      case flow_sequence_entry:
        if (var rc = flow_sequence_entry(&mut ctx, &mut is); !rc)
          return rc;

      case sequence_flow_entry:
        if (var rc = sequence_flow_entry(&mut ctx, &mut is); !rc)
          return rc;

      case indentless_sequence_entry:
        if (var rc = indentless_sequence_entry(&mut ctx, &mut is); !rc)
          return rc;

      case sequence_entry:
        if (var rc = sequence_entry(&mut ctx, &mut is); !rc)
          return rc;

      case block_mapping_key:
        if (var rc = block_mapping_key(&mut ctx, &mut is); !rc)
          return rc;

      case block_mapping_value:
        if (var rc = block_mapping_value(&mut ctx, &mut is); !rc)
          return rc;

      case flow_mapping_key:
        if (var rc = flow_mapping_key(&mut ctx, &mut is); !rc)
          return rc;

      case flow_mapping_value:
        if (var rc = flow_mapping_value(&mut ctx, &mut is); !rc)
          return rc;

      case mapping_flow_entry:
        if (var rc = mapping_flow_entry(&mut ctx, &mut is); !rc)
          return rc;

      case flow_sequence_entry_mapping_key:
        if (var rc = flow_sequence_entry_mapping_key(&mut ctx, &mut is); !rc)
          return rc;

      case flow_sequence_entry_mapping_value:
        if (var rc = flow_sequence_entry_mapping_value(&mut ctx, &mut is); !rc)
          return rc;

      case mapping_entry:
        if (var rc = mapping_entry(&mut ctx, &mut is); !rc)
          return rc;

      case block_node_or_indentless_sequence:
        if (var rc = parse_node(&mut ctx, &mut is, true, true); !rc)
          return rc;

      case flow_node:
        if (var rc = parse_node(&mut ctx, &mut is, false, false); !rc)
          return rc;

      case anchor_entry:
        if (var rc = anchor_entry(&mut ctx, &mut is); !rc)
          return rc;

      else:
        std::panic("invalid state");
    }
  }

  return ok;
}

pub fn parse(InputReader mut &is) throws(std::error) -> parse_result
{
  var result = parse_result();

  var ctx = parse_context();

  if (var rc = parse(&mut ctx, &mut is); !rc)
  {
    result.error = cast<errc>(-cast<i32>(rc));
    result.mark = ctx.tok.loc;
  }

  result.docs = &move ctx.stack;

  return result;
}
