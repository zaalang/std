//
// toml parser
//

import toml;
import toml.scanner;
import std.io : InputReader;
import std.vector;
import std.scan;

using toml::errc;
using toml::mark;
using toml::node;
using toml::token;
using toml::scanner;
using toml::scalar_style;

enum state
{
  stream_start = 0,
  document_content,
  block_node,
  block_mapping_entry,
  block_mapping_key,
  block_mapping_value,
  flow_sequence_entry,
  flow_mapping_key,
  flow_mapping_value,
  sequence_entry,
  sequence_flow_entry,
  mapping_entry,
  mapping_flow_entry,
  end,
}

enum result : i32
{
  ok = 0,

  fn bool(this &) -> bool
  {
    return cast<i32>(this) >= 0;
  }

  result(errc error)
    : this(cast<result>(-cast<i32>(error)))
  {
  }
}

pub struct parse_result
{
  pub errc error;
  pub mark mark;
  pub node doc;

  pub fn bool(this &) -> bool
  {
    return !this.error;
  }

  pub parse_result() = default;
  pub parse_result(parse_result&) = default;
  pub fn =(parse_result mut &, parse_result&) -> parse_result mut & = default;
  pub ~parse_result() = default;
}

struct parse_context
{
  token tok;
  state state;
  scanner scanner;
  std::vector<node> stack;
  std::vector<state> states;

  fn push_state(this mut &, state state) -> void
  {
    this.states.push_back(state);
  }

  fn pop_state(this mut &) -> state
  {
    return this.states.take_back();
  }

  #[lifetime(launder(this.tok))]
  fn consume_token(this mut &, var mut &is) throws(std::error) -> void
  {
    this.tok = this.scanner.fetch(&mut is);
  }

  parse_context()
  {
    states.reserve(32);
  }

  ~parse_context() = default;
}

#[lifetime(consume(rhs))]
fn merge(node mut &lhs, node mut &rhs) -> bool
{
  var ok = true;

  if (lhs.kind != rhs.kind)
    return false;

  switch (lhs)
  {
    case Array[array]:
      array.append(&move rhs.as_vec);

    case Map[map]:
      for (var mut &it : &move rhs.as_map)
      {
        if (var j = map.insert(&move it); !j.1)
        {
          std::launder(it);

          if (!merge(&mut map[j.0].value, &mut it.value))
            ok = false;
        }
      }

    else:
      ok = false;
  }

  return ok;
}

fn stream_start(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  ctx.state = state::document_content;
  ctx.stack.push_back(std::flat_hash_map<node, node>());

  return ok;
}

fn document_content(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case stream_end:
      ctx.state = state::end;

    case scalar:
      ctx.push_state(state::document_content);
      ctx.state = state::block_mapping_key;

    case l_square:
      ctx.push_state(state::document_content);
      ctx.state = state::block_mapping_entry;

    else:
      return errc::expected_block_content;
  }

  return ok;
}

fn block_node(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case l_square:
    case stream_end:
      ctx.state = ctx.pop_state();

    case scalar:
      ctx.push_state(state::block_node);
      ctx.state = state::block_mapping_key;

    else:
      return errc::expected_block_content;
  }

  return ok;
}

fn parse_scalar(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.style)
  {
    case plain:
      ctx.stack.push_back(node::from(ctx.tok.value));

    else:
      ctx.stack.push_back(&move ctx.tok.value);
  }

  ctx.consume_token(&mut is);

  ctx.state = ctx.pop_state();

  return ok;
}

fn parse_sequence(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case l_square:
      ctx.consume_token(&mut is);
      ctx.state = state::flow_sequence_entry;

    else:
      std::panic("unexpected");
  }

  ctx.stack.push_back(std::vector<node>());

  return ok;
}

fn sequence_entry(parse_context mut &ctx, InputReader mut &is) -> result
{
  var entry = ctx.stack.take_back();
  var mut &array = ctx.stack.back.Array;

  array.push_back(&move entry);

  ctx.state = ctx.pop_state();

  return ok;
}

fn block_mapping_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  ctx.consume_token(&mut is);

  var is_array = false;
  if (ctx.tok.type == token::type::l_square)
  {
    is_array = true;
    ctx.consume_token(&mut is);
  }

  for (;;)
  {
    switch (ctx.tok.type)
    {
      case scalar:
        ctx.push_state(state::mapping_entry);
        ctx.push_state(state::block_node);

        if (var rc = parse_scalar(&mut ctx, &mut is); !rc)
          return rc;

      else:
        return errc::expected_block_content;
    }

    if (ctx.tok.type != token::type::period)
      break;

    ctx.consume_token(&mut is);
    ctx.stack.push_back(std::flat_hash_map<node, node>());
  }

  if (is_array)
  {
    ctx.push_state(state::sequence_entry);
    ctx.stack.push_back(std::vector<node>());
  }

  ctx.stack.push_back(std::flat_hash_map<node, node>());

  if (ctx.tok.type != token::type::r_square)
    return errc::unmatched_bracket;

  if (is_array)
  {
    ctx.consume_token(&mut is);

    if (ctx.tok.type != token::type::r_square)
      return errc::unmatched_bracket;
  }

  ctx.consume_token(&mut is);

  return ok;
}

fn parse_mapping(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case l_brace:
      ctx.consume_token(&mut is);
      ctx.state = state::flow_mapping_key;

    else:
      std::panic("unexpected");
  }

  ctx.stack.push_back(std::flat_hash_map<node, node>());

  return ok;
}

fn mapping_entry(parse_context mut &ctx, InputReader mut &is) -> result
{
  var value = ctx.stack.take_back();
  var key = ctx.stack.take_back();
  var mut &map = ctx.stack.back.Map;

  if (var j = map.insert(&move key, &move value); !j.1)
  {
    std::launder(value);

    if (!merge(&mut map[j.0].value, &mut value))
      return errc::duplicate_key;
  }

  ctx.state = ctx.pop_state();

  return ok;
}

fn parse_node(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case l_square:
      if (var rc = parse_sequence(&mut ctx, &mut is); !rc)
        return rc;

    case l_brace:
      if (var rc = parse_mapping(&mut ctx, &mut is); !rc)
        return rc;

    case scalar:
      if (var rc = parse_scalar(&mut ctx, &mut is); !rc)
        return rc;

    else:
      switch (ctx.tok.type)
      {
        case bad_escape:
          return errc::bad_escape;

        case unexpected_end_of_line:
          return errc::unexpected_end_of_line;

        case unexpected_end_of_stream:
          return errc::unexpected_end_of_stream;

        else:
          return errc::invalid_value;
      }
  }

  return ok;
}

fn block_mapping_key(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case stream_end:
      ctx.state = ctx.pop_state();

    case scalar:
      ctx.push_state(state::block_mapping_value);

      if (var rc = parse_scalar(&mut ctx, &mut is); !rc)
        return rc;

    else:
      return errc::expected_block_mapping_key;
  }

  return ok;
}

fn block_mapping_value(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case equal:
      ctx.consume_token(&mut is);
      ctx.push_state(state::mapping_entry);

      if (var rc = parse_node(&mut ctx, &mut is); !rc)
        return rc;

    else:
      return errc::expected_block_mapping_value;
  }

  return ok;
}

fn flow_sequence_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case comma:
      return errc::expected_sequence_entry;

    case r_square:
      ctx.consume_token(&mut is);
      ctx.state = ctx.pop_state();

    else:
      ctx.push_state(state::flow_sequence_entry);
      ctx.push_state(state::sequence_flow_entry);

      if (var rc = parse_node(&mut ctx, &mut is); !rc)
        return rc;
  }

  return ok;
}

fn sequence_flow_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case comma:
    case r_square:
      if (var rc = sequence_entry(&mut ctx, &mut is); !rc)
        return rc;

      if (ctx.tok.type == token::type::comma)
        ctx.consume_token(&mut is);

    else:
      return errc::expected_comma;
  }

  return ok;
}

fn flow_mapping_key(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case r_brace:
      ctx.consume_token(&mut is);
      ctx.state = ctx.pop_state();

    case scalar:
      ctx.push_state(state::flow_mapping_value);

      if (var rc = parse_scalar(&mut ctx, &mut is); !rc)
        return rc;

    else:
      return errc::expected_block_mapping_key;
  }

  return ok;
}

fn flow_mapping_value(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case equal:
      ctx.consume_token(&mut is);
      ctx.push_state(state::flow_mapping_key);
      ctx.push_state(state::mapping_flow_entry);

      if (var rc = parse_node(&mut ctx, &mut is); !rc)
        return rc;

    else:
      return errc::expected_block_mapping_value;
  }

  return ok;
}

fn mapping_flow_entry(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  switch (ctx.tok.type)
  {
    case comma:
    case r_brace:
      if (var rc = mapping_entry(&mut ctx, &mut is); !rc)
        return rc;

      if (ctx.tok.type == token::type::comma)
        ctx.consume_token(&mut is);

    else:
      return errc::expected_comma;
  }

  return ok;
}

fn parse(parse_context mut &ctx, InputReader mut &is) throws(std::error) -> result
{
  ctx.consume_token(&mut is);

  while (ctx.state != state::end)
  {
    switch (ctx.state)
    {
      case stream_start:
        if (var rc = stream_start(&mut ctx, &mut is); !rc)
          return rc;

      case document_content:
        if (var rc = document_content(&mut ctx, &mut is); !rc)
          return rc;

      case block_node:
        if (var rc = block_node(&mut ctx, &mut is); !rc)
          return rc;

      case flow_sequence_entry:
        if (var rc = flow_sequence_entry(&mut ctx, &mut is); !rc)
          return rc;

      case sequence_flow_entry:
        if (var rc = sequence_flow_entry(&mut ctx, &mut is); !rc)
          return rc;

      case sequence_entry:
        if (var rc = sequence_entry(&mut ctx, &mut is); !rc)
          return rc;

      case block_mapping_entry:
        if (var rc = block_mapping_entry(&mut ctx, &mut is); !rc)
          return rc;

      case block_mapping_key:
        if (var rc = block_mapping_key(&mut ctx, &mut is); !rc)
          return rc;

      case block_mapping_value:
        if (var rc = block_mapping_value(&mut ctx, &mut is); !rc)
          return rc;

      case flow_mapping_key:
        if (var rc = flow_mapping_key(&mut ctx, &mut is); !rc)
          return rc;

      case flow_mapping_value:
        if (var rc = flow_mapping_value(&mut ctx, &mut is); !rc)
          return rc;

      case mapping_flow_entry:
        if (var rc = mapping_flow_entry(&mut ctx, &mut is); !rc)
          return rc;

      case mapping_entry:
        if (var rc = mapping_entry(&mut ctx, &mut is); !rc)
          return rc;

      else:
        std::panic("invalid state");
    }
  }

  return ok;
}

pub fn parse(InputReader mut &is) throws(std::error) -> parse_result
{
  var result = parse_result();

  var ctx = parse_context();

  if (var rc = parse(&mut ctx, &mut is); !rc)
  {
    result.error = cast<errc>(-cast<i32>(rc));
    result.mark = ctx.tok.loc;
  }

  if (ctx.stack.len != 0)
    result.doc = &move ctx.stack.front;

  return result;
}
