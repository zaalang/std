//
// std algorithm
//

import std.stdlib : assert;
import std.type;
import std.tuple;
import std.range : Iterator, RandomAccessIterator, Sentinal, Range;

pub fn swap<T>(T mut &a, T mut &b)
{
  var tmp = std::move(a);
  a = std::move(b);
  b = std::move(tmp);
}

pub fn fill<O, T>(O dst, Sentinal<O> end, T &value) -> O
{
  while (dst != end)
  {
    *dst++ = value;
  }

  return dst;
}

pub fn fill_n<O, T, N>(O dst, Sentinal<O> end, T &value, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = value;

    --n;
  }

  return dst;
}

pub fn copy<O, I>(O dst, Sentinal<O> end, I first, Sentinal<I> last) -> O
{
  while (first != last)
  {
    assert(dst != end);

    *dst++ = *first++;
  }
  
  return dst;
}

pub fn copy_n<O, I, N>(O dst, Sentinal<O> end, I first, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = *first++;
    
    --n;
  }
  
  return dst;
}

pub const fn min<T>(T &&a, T &&b)
  where !__is_arithmetic<T>
{
  return (b < a) ? &b : &a;
}

pub const fn max<T>(T &&a, T &&b)
  where !__is_arithmetic<T>
{
  return (a < b) ? &b : &a;
}

pub const fn min<Args>(Args & ...args)
  where __tuple_len<Args> > 2 && std::is_all_same<Args>
{
  var &result = args.0;
  #for(const k = 1; k < __tuple_len<Args>; ++k)
  {
    if (args.k < result)
      &result = &args.k;
  }

  return &result;
}

pub const fn max<Args>(Args & ...args)
  where __tuple_len<Args> > 2 && std::is_all_same<Args>
{
  var &result = args.0;
  #for(const k = 1; k < __tuple_len<Args>; ++k)
  {
    if (result < args.k)
      &result = &args.k;
  }

  return &result;
}

pub const less = fn (var &x, var &y) -> bool { return x < y; };
pub const greater = fn (var &x, var &y) -> bool { return x > y; };

pub fn sort<I, Cmp>(I first, Sentinal<I> last, Cmp &cmp = less)
  where __is_match<RandomAccessIterator, I>
{
  for(var i = first; i != last; ++i)
  {
    for(var j = first; j != i; ++j)
    {
      if (cmp(*i, *j))
        std::swap(*i, *j);
    }
  }
}

