//
// std algorithm
//

import std.stdlib : assert;
import std.type;
import std.tuple;
import std.range : Iterator, RandomAccessIterator, Sentinal, Range;

pub fn swap<T>(T mut &a, T mut &b)
{
  var tmp = std::move(a);
  a = std::move(b);
  b = std::move(tmp);
}

pub fn fill<O, T>(O dst, Sentinal<O> end, T &value) -> O
{
  while (dst != end)
  {
    *dst++ = value;
  }

  return dst;
}

pub fn fill_n<O, T, N>(O dst, Sentinal<O> end, T &value, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = value;

    --n;
  }

  return dst;
}

pub fn fill<T>(Range<T> mut &range, T &value) -> void
{
  for(var mut &element : range)
    element = value;
}

pub fn copy<O, I>(O dst, Sentinal<O> end, I first, Sentinal<I> last) -> O
{
  while (first != last)
  {
    assert(dst != end);

    *dst++ = *first++;
  }
  
  return dst;
}

pub fn copy_backward<O, I>(O dst, O end, I first, I last) -> O
{
  while (first != last)
  {
    assert(end != dst);

    *--end = *--last;
  }

  return end;
}

pub fn copy_n<O, I, N>(O dst, Sentinal<O> end, I first, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = *first++;
    
    --n;
  }
  
  return dst;
}

pub fn move<O, I>(O dst, Sentinal<O> end, I first, Sentinal<I> last) -> O
{
  while (first != last)
  {
    assert(dst != end);

    *dst++ = std::move(*first++);
  }

  return dst;
}

pub fn move_backward<O, I>(O dst, O end, I first, I last) -> O
{
  while (first != last)
  {
    assert(end != dst);

    *--end = std::move(*--last);
  }

  return end;
}

pub fn move_n<O, I, N>(O dst, Sentinal<O> end, I first, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = std::move(*first++);

    --n;
  }

  return dst;
}

pub fn transform<O, I, Func>(O dst, Sentinal<O> end, I first, Sentinal<I> last, Func &func) -> O
{
  while (first != last)
  {
    assert(dst != end);

    *dst++ = func(*first++);
  }

  return dst;
}

pub fn transform_backward<O, I, Func>(O dst, O end, I first, I last, Func &func) -> O
{
  while (first != last)
  {
    assert(end != dst);

    *--end = func(*--last);
  }

  return end;
}

pub fn transform_n<O, I, N, Func>(O dst, Sentinal<O> end, I first, N n, Func &func) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = func(*first++);

    --n;
  }

  return dst;
}

pub fn transform!<O, I, Func>(I first, Sentinal<I> last, Func &func) -> void
{
  for(; first != last; ++first)
  {
    *first = func(std::move(*first));
  }
}

pub fn transform!<T, Func>(Range<T> mut &range, Func &func) -> void
{
  var first = range.begin;

  for(var last = range.end; first != last; ++first)
  {
    range[first] = func(std::move(std::launder(range[first])));
  }
}

pub fn reverse!<I>(I first, I last) -> void
{
  for(; first != last && first != --last; ++first)
  {
    swap(&mut *first, &mut *last);
  }
}

pub fn reverse!<T, Func>(Range<T> mut &range) -> void
{
  var first = range.begin;

  for(var last = range.end; first != last && first != --last; ++first)
  {
    swap(&mut range[first], &mut range[last]);
  }
}

pub fn rotate_left<I>(I first, Sentinal<I> last) -> I
{
  if (first == last)
    return first;

  var tmp = std::move(*first);
  var lm1 = move(first, last, std::next(first), last);
  *lm1 = std::move(tmp);

  return lm1;
}

pub fn rotate_right<I>(I first, I last) -> I
{
  if (first == last)
    return last;

  var lm1 = std::prev(last);
  var tmp = std::move(*lm1);
  var fp1 = move_backward(first, last, first, lm1);
  *first = std::move(tmp);

  return fp1;
}

pub fn min<T>(T &&a, T &&b)
  where !__is_arithmetic<T>
{
  return (b < a) ? &b : &a;
}

pub fn max<T>(T &&a, T &&b)
  where !__is_arithmetic<T>
{
  return (a < b) ? &b : &a;
}

pub fn min<Args>(Args & ...args)
  where __tuple_len<Args> > 2 && std::is_all_same<Args>
{
  var &result = args.0;

  #for(const k = 1; k < __tuple_len<Args>; ++k)
  {
    if (args.#k < result)
      &result = &args.#k;
  }

  return &result;
}

pub fn max<Args>(Args & ...args)
  where __tuple_len<Args> > 2 && std::is_all_same<Args>
{
  var &result = args.0;

  #for(const k = 1; k < __tuple_len<Args>; ++k)
  {
    if (result < args.#k)
      &result = &args.#k;
  }

  return &result;
}

pub const less = fn (var &x, var &y) -> bool { return x < y; };
pub const greater = fn (var &x, var &y) -> bool { return x > y; };
pub const equal_to = fn (var &x, var &y) -> bool { return x == y; };

pub fn min_element<I, Cmp>(I first, Sentinal<I> last, Cmp &cmp = std::less) -> I
{
  var result = first;

  if (first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(*first, *result))
        result = first;
    }
  }

  return result;
}

pub fn min_element<T, Cmp>(Range<T> &&range, Cmp &cmp = std::less)
{
  var result = range.begin;

  if (var first = range.begin, var last = range.end; first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(range[first], range[result]))
        result = first;
    }
  }

  return result;
}

pub fn max_element<I, Cmp>(I first, Sentinal<I> last, Cmp &cmp = std::less) -> I
{
  var result = first;

  if (first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(*result, *first))
        result = first;
    }
  }

  return result;
}

pub fn max_element<T, Cmp>(Range<T> &&range, Cmp &cmp = std::less)
{
  var result = range.begin;

  if (var first = range.begin, var last = range.end; first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(range[result], range[first]))
        result = first;
    }
  }

  return result;
}

pub fn sort<I, Cmp>(I first, Sentinal<I> last, Cmp &cmp = std::less) -> void
  where __is_match<RandomAccessIterator, I> && requires (I i, I j, Cmp &cmp) { cmp(*i, *j); *i = *j; }
{
  for(var i = first; i != last; ++i)
  {
    for(var j = first; j != i; ++j)
    {
      if (cmp(*i, *j))
        swap(&mut *i, &mut *j);
    }
  }
}

pub fn sort<T, Cmp>(Range<T> mut &range, Cmp &cmp = std::less) -> void
{
  var first = range.begin;

  for(var i = first, var last = range.end; i != last; ++i)
  {
    for(var j = first; j != i; ++j)
    {
      if (cmp(range[i], range[j]))
        swap(&mut range[i], &mut range[j]);
    }
  }
}

pub fn lower_bound<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> I
  where __is_match<RandomAccessIterator, I> && requires (I i, Value &value, Cmp &cmp) { cmp(*i, value); }
{
  var count = std::distance(first, last);

  while (count > 0)
  {
    var m = count / 2;
    var it = first + m;

    if (cmp(*it, value))
    {
      first = ++it;
      count -= m + 1;
    }
    else
    {
      count = m;
    }
  }

  return first;
}

pub fn lower_bound<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
  where requires (typeof(range) range, Value &value, Cmp &cmp) { lower_bound(range.begin, range.end, value, cmp); }
{
  return lower_bound(range.begin, range.end, value, cmp);
}

pub fn upper_bound<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> I
  where __is_match<RandomAccessIterator, I> && requires (I i, Value &value, Cmp &cmp) { cmp(value, *i); }
{
  var count = std::distance(first, last);

  while (count > 0)
  {
    var m = count / 2;
    var it = first + m;

    if (!cmp(value, *it))
    {
      first = ++it;
      count -= m + 1;
    }
    else
    {
      count = m;
    }
  }

  return first;
}

pub fn upper_bound<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
  where requires (typeof(range) range, Value &value, Cmp &cmp) { upper_bound(range.begin, range.end, value, cmp); }
{
  return upper_bound(range.begin, range.end, value, cmp);
}

pub fn equal_range<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> (I, I)
  where __is_match<RandomAccessIterator, I> && requires (I i, Value &value, Cmp &cmp) { cmp(*i, value); cmp(value, *i); }
{
  return (lower_bound(first, last, value, cmp), upper_bound(first, last, value, cmp));
}

pub fn equal_range<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
  where requires (typeof(range) range, Value &value, Cmp &cmp) { equal_range(range.begin, range.end, value, cmp); }
{
  return equal_range(range.begin, range.end, value, cmp);
}

pub fn binary_search<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> I
  where __is_match<RandomAccessIterator, I> && requires (I i, Value &value, Cmp &cmp) { cmp(*i, value); }
{
  var j = lower_bound(first, last, value, cmp);

  if (j == last || cmp(value, *j))
    return last;

  return j;
}

pub fn binary_search<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
  where requires (typeof(range) range, Value &value, Cmp &cmp) { binary_search(range.begin, range.end, value, cmp); }
{
  return binary_search(range.begin, range.end, value, cmp);
}

pub fn count<I, Value>(I first, Sentinal<I> last, Value &value) -> usize
  where __is_match<Iterator, I> && requires (I i, Value &value) { *i == value; }
{
  var count = 0;

  for(; first != last; ++first)
  {
    if (*first == value)
      ++count;
  }

  return count;
}

pub fn count<T, Value>(Range<T> &&range, Value &value) -> usize
  match (Value value) { T(value); }
{
  var count = 0;

  for(var first = range.begin, var last = range.end; first != last; ++first)
  {
    if (range[first] == value)
      ++count;
  }

  return count;
}

pub fn count_if<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> usize
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  var count = 0;

  for(; first != last; ++first)
  {
    if (pred(*first))
      ++count;
  }

  return count;
}

pub fn count_if<T, Pred>(Range<T> &&range, Pred &pred)
{
  var count = 0;

  for(var first = range.begin, var last = range.end; first != last; ++first)
  {
    if (pred(range[first]))
      ++count;
  }

  return count;
}

pub fn find<I, Value>(I first, Sentinal<I> last, Value &value) -> I
  where __is_match<Iterator, I> && requires (I i, Value &value) { *i == value; }
{
  for(; first != last; ++first)
  {
    if (*first == value)
      return first;
  }

  return first;
}

pub fn find<T, Value>(Range<T> &&range, Value &value)
  match (Value value) { T(value); }
{
  var first = range.begin;

  for(var last = range.end; first != last; ++first)
  {
    if (range[first] == value)
      return first;
  }

  return first;
}

pub fn find_if<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> I
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  for (; first != last; ++first)
  {
    if (pred(*first))
      return first;
  }

  return first;
}

pub fn find_if<T, Pred>(Range<T> &&range, Pred &pred)
{
  var first = range.begin;

  for(var last = range.end; first != last; ++first)
  {
    if (pred(range[first]))
      return first;
  }

  return first;
}

pub fn remove<I, Value>(I first, Sentinal<I> last, Value &value) -> I
  where __is_match<Iterator, I> && requires (I i, Value &value) { *i == value; }
{
  first = find(first, last, value);

  if (first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!(*i == value))
        *first++ = std::move(*i);
    }
  }

  return first;
}

pub fn remove<T, Value>(Range<T> &&range, Value &value)
  match (Value value) { T(value); }
{
  var first = find(range, value);

  if (var last = range.end; first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!(range[i] == value))
        range[first++] = std::move(range[i]);
    }
  }

  return first;
}

pub fn remove_if<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> I
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  first = find_if(first, last, pred);

  if (first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!pred(*i))
        *first++ = std::move(*i);
    }
  }

  return first;
}

pub fn remove_if<T, Pred>(Range<T> &&range, Pred &pred)
{
  var first = find_if(range, pred);

  if (var last = range.end; first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!pred(range[i]))
        range[first++] = std::move(range[i]);
    }
  }

  return first;
}

pub fn all_of<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> bool
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  return find_if(first, last, fn[pred](var &k) { return !pred(k); }) == last;
}

pub fn all_of<T, Pred>(Range<T> &range, Pred &pred) -> bool
{
  return find_if(range, fn[pred](var &k) { return !pred(k); }) == range.end;
}

pub fn any_of<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> bool
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  return find_if(first, last, pred) != last;
}

pub fn any_of<T, Pred>(Range<T> &range, Pred &pred) -> bool
{
  return find_if(range, pred) != range.end;
}

pub fn none_of<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> bool
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  return find_if(first, last, pred) == last;
}

pub fn none_of<T, Pred>(Range<T> &range, Pred &pred) -> bool
{
  return find_if(range, pred) == range.end;
}
