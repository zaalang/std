//
// std algorithm
//

import std.stdlib : assert;
import std.range : Iterator, BidirectionalIterator, RandomAccessIterator, Sentinal, Range;
import std.type;
import std.tuple;

pub import std.algorithm.heap;
pub import std.algorithm.sort;
pub import std.algorithm.unique;
pub import std.algorithm.reverse;
pub import std.algorithm.rotate;
pub import std.algorithm.iteration;
pub import std.algorithm.partition;
pub import std.algorithm.permutation;

pub fn swap<T>(T mut &a, T mut &b)
{
  var tmp = &move a;
  a = &move b;
  b = &move tmp;
}

pub fn fill<O, T>(O dst, Sentinal<O> end, T &value) -> O
{
  while (dst != end)
  {
    *dst++ = value;
  }

  return dst;
}

pub fn fill_n<O, T, N>(O dst, Sentinal<O> end, T &value, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = value;

    --n;
  }

  return dst;
}

pub fn fill<T>(Range<T> mut &range, T &value) -> void
{
  for(var mut &element : range)
    element = value;
}

pub fn copy<O, I>(O dst, Sentinal<O> end, I first, Sentinal<I> last) -> O
{
  while (first != last)
  {
    assert(dst != end);

    *dst++ = *first++;
  }
  
  return dst;
}

pub fn copy_backward<O, I>(O dst, O end, I first, I last) -> O
{
  while (first != last)
  {
    assert(end != dst);

    *--end = *--last;
  }

  return end;
}

pub fn copy_n<O, I, N>(O dst, Sentinal<O> end, I first, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = *first++;
    
    --n;
  }
  
  return dst;
}

pub fn move<O, I>(O dst, Sentinal<O> end, I first, Sentinal<I> last) -> O
{
  while (first != last)
  {
    assert(dst != end);

    *dst++ = &move *first++;
  }

  return dst;
}

pub fn move_backward<O, I>(O dst, O end, I first, I last) -> O
{
  while (first != last)
  {
    assert(end != dst);

    *--end = &move *--last;
  }

  return end;
}

pub fn move_n<O, I, N>(O dst, Sentinal<O> end, I first, N n) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = &move *first++;

    --n;
  }

  return dst;
}

pub fn transform<O, I, Func>(O dst, Sentinal<O> end, I first, Sentinal<I> last, Func &func) -> O
{
  while (first != last)
  {
    assert(dst != end);

    *dst++ = func(*first++);
  }

  return dst;
}

pub fn transform_backward<O, I, Func>(O dst, O end, I first, I last, Func &func) -> O
{
  while (first != last)
  {
    assert(end != dst);

    *--end = func(*--last);
  }

  return end;
}

pub fn transform_n<O, I, N, Func>(O dst, Sentinal<O> end, I first, N n, Func &func) -> O
{
  while (n > 0)
  {
    assert(dst != end);

    *dst++ = func(*first++);

    --n;
  }

  return dst;
}

pub fn transform<O, I, Func>(I first, Sentinal<I> last, Func &func) -> void
{
  for(; first != last; ++first)
  {
    *first = func(&move *first);
  }
}

#[lifetime(depend(range))]
pub fn transform!<T, Func>(Range<T> mut &range, Func &func)
{
  var first = range.begin;

  for(var last = range.end; first != last; ++first)
  {
    range[first] = func(&move std::launder(range[first]));
  }

  return &range;
}

pub fn min<T>(T &&a, T &&b)
  where !__is_arithmetic<T>
{
  return (b < a) ? &b : &a;
}

pub fn max<T>(T &&a, T &&b)
  where !__is_arithmetic<T>
{
  return (a < b) ? &b : &a;
}

pub fn min<Args>(Args & ...args)
  where __tuple_len<Args> > 2 && std::is_all_same<Args>
{
  var &result = args.0;

  #for(const k = 1; k < __tuple_len<Args>; ++k)
  {
    if (args.#k < result)
      &result = &args.#k;
  }

  return &result;
}

pub fn max<Args>(Args & ...args)
  where __tuple_len<Args> > 2 && std::is_all_same<Args>
{
  var &result = args.0;

  #for(const k = 1; k < __tuple_len<Args>; ++k)
  {
    if (result < args.#k)
      &result = &args.#k;
  }

  return &result;
}

pub const less = fn (var &x, var &y) -> bool { return x < y; };
pub const greater = fn (var &x, var &y) -> bool { return x > y; };
pub const equal_to = fn (var &x, var &y) -> bool { return x == y; };

pub fn min_element<I, Cmp>(I first, Sentinal<I> last, Cmp &cmp = std::less) -> I
{
  var result = first;

  if (first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(*first, *result))
        result = first;
    }
  }

  return result;
}

#[lifetime(depend(range))]
pub fn min_element<T, Cmp>(Range<T> &&range, Cmp &cmp = std::less)
{
  var result = range.begin;

  if (var first = range.begin, var last = range.end; first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(range[first], range[result]))
        result = first;
    }
  }

  return result;
}

pub fn max_element<I, Cmp>(I first, Sentinal<I> last, Cmp &cmp = std::less) -> I
{
  var result = first;

  if (first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(*result, *first))
        result = first;
    }
  }

  return result;
}

#[lifetime(depend(range))]
pub fn max_element<T, Cmp>(Range<T> &&range, Cmp &cmp = std::less)
{
  var result = range.begin;

  if (var first = range.begin, var last = range.end; first != last)
  {
    for(++first; first != last; ++first)
    {
      if (cmp(range[result], range[first]))
        result = first;
    }
  }

  return result;
}

pub fn lower_bound<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> I
  where requires (I i, Value &value, Cmp &cmp) { cmp(*i, value); }
{
  for(var len = std::distance(first, last); len > 0; )
  {
    var m = len / 2;
    var it = std::next(first, m);

    if (cmp(*it, value))
    {
      first = ++it;
      len -= m + 1;
    }
    else
    {
      len = m;
    }
  }

  return first;
}

#[lifetime(depend(range))]
pub fn lower_bound<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
{
  var first = range.begin;

  for(var len = range.len; len > 0; )
  {
    var m = len / 2;
    var it = std::next(first, m);

    if (cmp(range[it], value))
    {
      first = ++it;
      len -= m + 1;
    }
    else
    {
      len = m;
    }
  }

  return first;
}

pub fn upper_bound<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> I
  where requires (I i, Value &value, Cmp &cmp) { cmp(value, *i); }
{
  for(var len = std::distance(first, last); len > 0; )
  {
    var m = len / 2;
    var it = std::next(first, m);

    if (!cmp(value, *it))
    {
      first = ++it;
      len -= m + 1;
    }
    else
    {
      len = m;
    }
  }

  return first;
}

#[lifetime(depend(range))]
pub fn upper_bound<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
{
  var first = range.begin;

  for(var len = range.len; len > 0; )
  {
    var m = len / 2;
    var it = std::next(first, m);

    if (!cmp(value, range[it]))
    {
      first = ++it;
      len -= m + 1;
    }
    else
    {
      len = m;
    }
  }

  return first;
}

pub fn equal_range<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> (I, I)
  where requires (I i, Value &value, Cmp &cmp) { cmp(*i, value); cmp(value, *i); }
{
  return (lower_bound(first, last, value, cmp), upper_bound(first, last, value, cmp));
}

#[lifetime(depend(range))]
pub fn equal_range<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
{
  return (lower_bound(&&range, value, cmp), upper_bound(&&range, value, cmp));
}

pub fn binary_search<I, Value, Cmp>(I first, Sentinal<I> last, Value &value, Cmp &cmp = std::less) -> I
  where requires (I i, Value &value, Cmp &cmp) { cmp(*i, value); }
{
  var j = lower_bound(first, last, value, cmp);

  if (j == last || cmp(value, *j))
    return last;

  return j;
}

#[lifetime(depend(range))]
pub fn binary_search<T, Value, Cmp>(Range<T> &&range, Value &value, Cmp &cmp = std::less)
  match (Value value) { T(value); }
{
  var j = lower_bound(range, value, cmp);

  if (j == range.end || cmp(value, range[j]))
    return range.end;

  return j;
}

pub fn count<I, Value>(I first, Sentinal<I> last, Value &value) -> usize
  where __is_match<Iterator, I> && requires (I i, Value &value) { *i == value; }
{
  var count = 0;

  for(; first != last; ++first)
  {
    if (*first == value)
      ++count;
  }

  return count;
}

pub fn count<T, Value>(Range<T> &&range, Value &value) -> usize
  match (Value value) { T(value); }
{
  var count = 0;

  for(var first = range.begin, var last = range.end; first != last; ++first)
  {
    if (range[first] == value)
      ++count;
  }

  return count;
}

pub fn count_if<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> usize
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  var count = 0;

  for(; first != last; ++first)
  {
    if (pred(*first))
      ++count;
  }

  return count;
}

pub fn count_if<T, Pred>(Range<T> &&range, Pred &pred) -> usize
{
  var count = 0;

  for(var first = range.begin, var last = range.end; first != last; ++first)
  {
    if (pred(range[first]))
      ++count;
  }

  return count;
}

pub fn count_if_not<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> usize
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  var count = 0;

  for(; first != last; ++first)
  {
    if (!pred(*first))
      ++count;
  }

  return count;
}

pub fn count_if_not<T, Pred>(Range<T> &&range, Pred &pred) -> usize
{
  var count = 0;

  for(var first = range.begin, var last = range.end; first != last; ++first)
  {
    if (!pred(range[first]))
      ++count;
  }

  return count;
}

pub fn find<I, Value>(I first, Sentinal<I> last, Value &value) -> I
  where __is_match<Iterator, I> && requires (I i, Value &value) { *i == value; }
{
  for(; first != last; ++first)
  {
    if (*first == value)
      return first;
  }

  return first;
}

#[lifetime(depend(range))]
pub fn find<T, Value>(Range<T> &&range, Value &value)
  match (Value value) { T(value); }
{
  var first = range.begin;

  for(var last = range.end; first != last; ++first)
  {
    if (range[first] == value)
      return first;
  }

  return first;
}

pub fn find_if<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> I
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  for (; first != last; ++first)
  {
    if (pred(*first))
      return first;
  }

  return first;
}

#[lifetime(depend(range))]
pub fn find_if<T, Pred>(Range<T> &&range, Pred &pred)
{
  var first = range.begin;

  for(var last = range.end; first != last; ++first)
  {
    if (pred(range[first]))
      return first;
  }

  return first;
}

pub fn find_if_not<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> I
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  for (; first != last; ++first)
  {
    if (!pred(*first))
      return first;
  }

  return first;
}

#[lifetime(depend(range))]
pub fn find_if_not<T, Pred>(Range<T> &&range, Pred &pred)
{
  var first = range.begin;

  for(var last = range.end; first != last; ++first)
  {
    if (!pred(range[first]))
      return first;
  }

  return first;
}

pub fn remove<I, Value>(I first, Sentinal<I> last, Value &value) -> I
  where __is_match<Iterator, I> && requires (I i, Value &value) { *i == value; }
{
  first = find(first, last, value);

  if (first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!(*i == value))
        *first++ = &move *i;
    }
  }

  return first;
}

#[lifetime(depend(range))]
pub fn remove<T, Value>(Range<T> &&range, Value &value)
  match (Value value) { T(value); }
{
  var first = find(range, value);

  if (var last = range.end; first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!(range[i] == value))
        range[first++] = &move range[i];
    }
  }

  return first;
}

pub fn remove_if<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> I
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  first = find_if(first, last, pred);

  if (first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!pred(*i))
        *first++ = &move *i;
    }
  }

  return first;
}

#[lifetime(depend(range))]
pub fn remove_if<T, Pred>(Range<T> &&range, Pred &pred)
{
  var first = find_if(range, pred);

  if (var last = range.end; first != last)
  {
    for(var i = first; ++i != last; )
    {
      if (!pred(range[i]))
        range[first++] = &move range[i];
    }
  }

  return first;
}

pub fn all_of<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> bool
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  return find_if(first, last, fn[pred](var &k) { return !pred(k); }) == last;
}

pub fn all_of<T, Pred>(Range<T> &range, Pred &pred) -> bool
{
  return find_if(range, fn[pred](var &k) { return !pred(k); }) == range.end;
}

pub fn any_of<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> bool
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  return find_if(first, last, pred) != last;
}

pub fn any_of<T, Pred>(Range<T> &range, Pred &pred) -> bool
{
  return find_if(range, pred) != range.end;
}

pub fn none_of<I, Pred>(I first, Sentinal<I> last, Pred &pred) -> bool
  where __is_match<Iterator, I> && requires (I i, Pred &pred) { pred(*i); }
{
  return find_if(first, last, pred) == last;
}

pub fn none_of<T, Pred>(Range<T> &range, Pred &pred) -> bool
{
  return find_if(range, pred) == range.end;
}
