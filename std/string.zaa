//
// std string
//

import std.span : Span;
import std.stdlib : assert;
import std.algorithm : swap;
import std.memory : memcpy, memmove, memchr, memrchr, memcmp;
import std.unicode : is_whitespace, to_uppercase, to_lowercase;
import std.range : Sentinal, Range;
import std.fmt;
import std.bits.utf as utf;

pub concept String
{
  requires<T> (T x) { x.len; };
  requires<T> (T x) { x.data; };
  requires<T> (T x) -> u8 { return *x.data; };
  requires<T> (T x) { x.begin; };
  requires<T> (T x) { x.end; };
}

pub using string_literal = typeof("");

pub struct string_ref : std::span<u8>
{
  #[lifetime(clone(data))]
  pub string_ref(u8 *data, usize len)
    : super(data, len)
  {
  }

  pub fn String(this &) -> string_view
  {
    return string_view(this.data, this.len);
  }

  pub string_ref(string_ref &that) = default;
  pub ~string_ref() = default;
}

pub struct string_view : std::span<u8>
{
  #[lifetime(clone(data))]
  pub string_view(u8 *data, usize len)
    : super(data, len)
  {
  }

  #[lifetime(clone(beg))]
  pub string_view(u8 *beg, u8 *end)
    : super(beg, end)
  {
  }

  #[lifetime(follow(str.data))]
  pub string_view(String &str)
    : super(str.data, str.len)
  {
  }

  #[lifetime(clone(this))]
  pub fn [](this&, (usize, usize) range) -> string_view
  {
    assert(range.0 <= range.1 && range.0 <= this.len && range.1 <= this.len);

    return string_view(this.data + range.0, this.data + range.1);
  }

  #[lifetime(clone(this))]
  pub fn [](this&, (usize, usize, void) range) -> string_view
  {
    assert(range.0 <= range.1 && range.0 <= this.len && range.1 + 1 <= this.len);

    return string_view(this.data + range.0, this.data + range.1 + 1);
  }

  pub struct char_iterator : u8 *
  {
    pub char_iterator() = default;
    pub char_iterator(char_iterator&) = default;
    pub fn =(char_iterator mut &this, char_iterator &that) -> char_iterator mut & = default;
    pub ~char_iterator() = default;

    #[lifetime(depend(this))]
    pub fn *(char_iterator &this) -> char &
    {
      return &this.codepoint;
    }

    #[lifetime(depend(this))]
    pub fn ++(char_iterator mut &this) -> char_iterator mut &
    {
      this.super += this.n;

      this.n = 0;

      var state = 0;
      for(var ch = this.super; ch != this.end; ++ch)
      {
        this.n += 1;

        if (utf::decode(state, this.codepoint, *ch) == 0)
          break;
      }

      return &this;
    }

    #[lifetime(depend(this))]
    pub fn --(char_iterator mut &this) -> char_iterator mut &
    {
      this.n = utf::len_last(this.beg, this.super);

      var state = 0;
      for(var ch = this.super - this.n; ch != this.super; ++ch)
      {
        utf::decode(state, this.codepoint, *ch);
      }

      this.super -= this.n;

      return &this;
    }

    pub fn -(u8 *rhs, char_iterator &lhs) -> usize = delete;
    pub fn +(char_iterator &lhs, usize) -> char_iterator = delete;
    pub fn -(char_iterator &lhs, usize) -> char_iterator = delete;

    pub fn ==(char_iterator &lhs, end_iterator rhs) -> bool
    {
      return lhs.n == 0;
    }

    pub fn len(char_iterator &this) -> usize
    {
      return this.n;
    }

    char_iterator(u8 *beg, u8 *end, u8 *cursor)
      : super(cursor), beg(beg), end(end)
    {
    }

    usize n;
    char codepoint;
    u8 *beg, u8 *end
  }

  pub struct line_iterator : u8 *
  {
    pub line_iterator() = default;
    pub line_iterator(line_iterator&) = default;
    pub fn =(line_iterator mut &this, line_iterator &that) -> line_iterator mut & = default;
    pub ~line_iterator() = default;

    #[lifetime(clone(this))]
    pub fn *(line_iterator &this) -> string_ref
    {
      return string_ref(this.super, this.m);
    }

    #[lifetime(depend(this))]
    pub fn ++(line_iterator mut &this) -> line_iterator mut &
    {
      this.super += this.n;

      if (this.super != this.end)
      {
        this.n = memchr(this.super, cast('\n'), this.end - this.super);

        this.m = this.n;

        if (this.super + this.n != this.end)
        {
          if (this.m != 0 && *(this.super + this.m - 1) == cast('\r'))
            this.m -= 1;

          this.n += 1;
        }
      }
      else
      {
        this.n = this.m = 0;
      }

      return &this;
    }

    pub fn -(u8 *rhs, line_iterator &lhs) -> usize = delete;
    pub fn +(line_iterator &lhs, usize) -> line_iterator = delete;
    pub fn -(line_iterator &lhs, usize) -> line_iterator = delete;

    pub fn ==(line_iterator &lhs, end_iterator rhs) -> bool
    {
      return lhs.n == 0;
    }

    line_iterator(u8 *beg, u8 *end)
      : super(beg), end(end)
    {
    }

    usize n, usize m;
    u8 *end;
  }

  pub struct word_iterator : u8 *
  {
    pub word_iterator() = default;
    pub word_iterator(word_iterator&) = default;
    pub fn =(word_iterator mut &this, word_iterator &that) -> word_iterator mut & = default;
    pub ~word_iterator() = default;

    #[lifetime(clone(this))]
    pub fn *(word_iterator &this) -> string_ref
    {
      return string_ref(this.super, this.n);
    }

    #[lifetime(depend(this))]
    pub fn ++(word_iterator mut &this) -> word_iterator mut &
    {
      this.super += this.n;
      this.super = find_first_not_of(string_view(this.super, this.end), this.delimiters);

      if (this.super != this.end)
      {
        this.n = find_first_of(string_view(this.super + 1, this.end), this.delimiters) - this.super;
      }
      else
      {
        this.n = 0;
      }

      return &this;
    }

    pub fn -(u8 *rhs, word_iterator &lhs) -> usize = delete;
    pub fn +(word_iterator &lhs, usize) -> word_iterator = delete;
    pub fn -(word_iterator &lhs, usize) -> word_iterator = delete;

    pub fn ==(word_iterator &lhs, end_iterator rhs) -> bool
    {
      return lhs.n == 0;
    }

    word_iterator(u8 *beg, u8 *end, String &delimiters)
      : super(beg), end(end), delimiters(delimiters.data, delimiters.len)
    {
    }

    usize n;
    string_view delimiters;
    u8 *end;
  }

  pub struct split_iterator : u8 *
  {
    pub split_iterator() = default;
    pub split_iterator(split_iterator&) = default;
    pub fn =(split_iterator mut &this, split_iterator &that) -> split_iterator mut & = default;
    pub ~split_iterator() = default;

    #[lifetime(clone(this))]
    pub fn *(split_iterator &this) -> string_ref
    {
      return string_ref(this.super, this.m);
    }

    #[lifetime(depend(this))]
    pub fn ++(split_iterator mut &this) -> split_iterator mut &
    {
      this.super += this.n;

      if (this.count > 2)
      {
        var it = find_first(string_view(this.super, this.end), this.seperator);

        this.n = this.m = it - this.super;

        if (it != this.end)
        {
          this.n += this.seperator.len;
        }
        else
        {
          this.count = 2;
        }
      }
      else
      {
        this.n = this.m = this.end - this.super;
      }

      if (this.inclusive)
      {
        this.m = this.n;

        if (this.n == 0)
          this.count = 1;
      }

      this.count -= 1;

      return &this;
    }

    pub fn -(u8 *rhs, split_iterator &lhs) -> usize = delete;
    pub fn +(split_iterator &lhs, usize) -> split_iterator = delete;
    pub fn -(split_iterator &lhs, usize) -> split_iterator = delete;

    pub fn ==(split_iterator &lhs, end_iterator rhs) -> bool
    {
      return lhs.count == 0;//lhs.n + lhs.leftover == 0;
    }

    split_iterator(u8 *beg, u8 *end, String &seperator, bool inclusive, usize count)
      : super(beg), end(end), seperator(seperator.data, seperator.len), inclusive(inclusive), count(count)
    {
    }

    usize count;
    bool inclusive;
    usize n, usize m;
    string_view seperator;
    u8 *end;
  }

  struct end_iterator
  {
    end_iterator() = default;
    end_iterator(end_iterator&) = default;
    fn =(end_iterator mut &this, end_iterator &that) -> end_iterator mut & = default;
    ~end_iterator() = default;
  }

  #[lifetime(clone(this))]
  pub fn chars(this &) -> std::iterator_pair<char_iterator, char_iterator>
  {
    return std::iterator_pair(++char_iterator(this.begin, this.end, this.begin), char_iterator(this.begin, this.end, this.end));
  }

  #[lifetime(clone(this))]
  pub fn lines(this &) -> std::iterator_pair<line_iterator, end_iterator>
  {
    return std::iterator_pair(++line_iterator(this.begin, this.end), end_iterator());
  }

  #[lifetime(clone(this))]
  pub fn words(this &, String &delimiters = " \r\n\t") -> std::iterator_pair<word_iterator, end_iterator>
  {
    return std::iterator_pair(++word_iterator(this.begin, this.end, delimiters), end_iterator());
  }

  #[lifetime(clone(this))]
  pub fn split(this &, String &seperator) -> std::iterator_pair<split_iterator, end_iterator>
  {
    return std::iterator_pair(++split_iterator(this.begin, this.end, seperator, false, ~0), end_iterator());
  }

  #[lifetime(clone(this))]
  pub fn split_after(this &, String &seperator) -> std::iterator_pair<split_iterator, end_iterator>
  {
    return std::iterator_pair(++split_iterator(this.begin, this.end, seperator, true, ~0), end_iterator());
  }

  #[lifetime(clone(this))]
  pub fn split_n(this &, usize n, String &seperator) -> std::iterator_pair<split_iterator, end_iterator>
  {
    return std::iterator_pair(++split_iterator(this.begin, this.end, seperator, false, n + 1), end_iterator());
  }

  #[lifetime(clone(this))]
  pub fn split_after_n(this &, usize n, String &seperator) -> std::iterator_pair<split_iterator, end_iterator>
  {
    return std::iterator_pair(++split_iterator(this.begin, this.end, seperator, true, n + 1), end_iterator());
  }

  pub string_view() = default;
  pub string_view(string_view &that) = default;
  pub fn =(this mut &, string_view &that) -> string_view mut & = default;
  pub ~string_view() = default;
}

pub fn String(string_literal &str) -> string_view
{
  return string_view(str.data, str.len);
}

pub struct string_stream
{
  pub std::span<u8> buffer;

  pub string_stream(u8 *data, usize len)
    : buffer(data, len)
  {
  }

  pub string_stream(u8 *beg, u8 *end)
    : buffer(beg, end)
  {
  }

  pub string_stream(String &str)
    : buffer(str.data, str.len)
  {
  }

  pub fn capacity(this &) -> usize
  {
    return buffer.len;
  }

  pub fn fetch(this mut &) -> std::span<u8>
  {
    return this.buffer;
  }

  pub fn pack_and_fetch(this mut &) -> std::span<u8>
  {
    return this.buffer;
  }

  pub fn discard(this mut &, usize len) -> void
  {
    this.buffer.remove_prefix(len);
  }

  pub fn read(this mut &, u8 mut *data, usize len) -> usize
  {
    var bytes = std::min(this.buffer.len, len);

    std::memcpy(data, this.buffer.data, bytes);

    this.buffer.remove_prefix(bytes);

    return bytes;
  }

  pub fn lines(this mut &)
  {
    return string_view(this.buffer.data, this.buffer.len).lines();
  }

  pub ~string_stream() = default;
}

pub struct string<Allocator = std::allocator, N = 24>
{
  pub string(Allocator &allocator = Allocator())
    : _allocator(allocator),
      _smallbuffer(void)
  {
    init(this);
  }
  
  pub string(String &&other, Allocator &allocator = Allocator())
    : _allocator(allocator),
      _smallbuffer(void)
  {
    init(this);

    #if (__is_rvalue<typeof(other)> && requires (typeof(this) this, typeof(other) other) { take(this, other); })
      this.take(other);
    #else
      this.insert(this._len, other.data, other.len);
  }

  #[lifetime(poison(this))]
  pub fn =(this mut &, String &&other) -> string mut &
  {
    if (this._data <= other.data && other.data < this._data + this._len)
    {
      memmove(this._data, other.data, other.len);
      this._len = other.len;
      return &this;
    }

    clear(this);

    #if (__is_rvalue<typeof(other)> && requires (typeof(this) this, typeof(other) other) { take(this, other); })
      this.take(other);
    #else
      this.insert(this._len, other.data, other.len);

    return &this;
  }

  pub fn with_size(usize size, Allocator &allocator = Allocator()) -> string
  {
    var result = string(allocator);

    result.resize(size);

    return result;
  }

  pub fn with_capacity(usize capacity, Allocator &allocator = Allocator()) -> string
  {
    var result = string(allocator);

    result.reserve(capacity);

    return result;
  }

  pub fn from_utf8(u8 *data, usize len, Allocator &allocator = Allocator()) -> string
  {
    return string(string_view(data, len), allocator);
  }

  pub fn from_utf8(u8 *beg, u8 *end, Allocator &allocator = Allocator()) -> string
  {
    return string(string_view(beg, end), allocator);
  }

  pub ~string()
  {
    this._len = 0;

    if (_data != _smallbuffer.data)
      this._allocator.free(_data, _capacity);
  }
  
  pub fn len(this &) -> usize
  {
    return this._len;
  }
  
  pub fn empty(this &) -> bool
  {
    return this._len == 0;
  }
  
  pub fn capacity(this &) -> usize
  {
    return this._capacity;
  }

  #[lifetime(depend(this))]
  pub fn data(this &&)
  {
    return this._data;
  }

  pub fn allocator(this &) -> Allocator &
  {
    return &this._allocator;
  }

  #[lifetime(depend(this))]
  pub fn [](this &&, usize index)
  {
    assert(index < this._len);

    return &*(this._data + index);
  }

  #[lifetime(depend(this))]
  pub fn [](this &, (usize, usize) range) -> string_view
  {
    assert(range.0 <= range.1 && range.0 <= this._len && range.1 <= this._len);

    return string_view(this._data + range.0, this._data + range.1);
  }

  #[lifetime(depend(this))]
  pub fn [](this &, (usize, usize, void) range) -> string_view
  {
    assert(range.0 <= range.1 && range.0 <= this._len && range.1 + 1 <= this._len);

    return string_view(this._data + range.0, this._data + range.1 + 1);
  }

  #[lifetime(depend(this))]
  pub fn begin(this &&)
  {
    return this._data;
  }

  #[lifetime(depend(this))]
  pub fn end(this &&)
  {
    return this._data + this._len;
  }

  pub fn as_literal(this &)
  {
    return string_literal(this._data, this._len);
  }

  #[lifetime(poison(this))]
  pub fn reserve(this mut &, usize capacity) -> void
  {
    if (this._capacity < capacity)
    {
      var data = cast<u8 mut *>(this._allocator.allocate(capacity, alignof<u8>));
      
      memcpy(data, this._data, this._len);
      swap(this._data, data);
      swap(this._capacity, capacity);

      if (data != this._smallbuffer.data)
        this._allocator.free(data, capacity);
    }
  }

  #[lifetime(poison(this))]
  pub fn resize(this mut &, usize size) -> void
  {
    reserve(this, size);

    this._len = size;
  }

  #[lifetime(poison(this))]
  pub fn clear(this mut &) -> void
  {
    this._len = 0;
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert(this mut &, u8 *position, u8 ch) -> (u8 mut *, usize)
  {
    return insert(this, position - this.begin, ch);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert(this mut &, usize position, u8 ch) -> (u8 mut *, usize)
  {
    return insert(this, position, string_view(&ch, 1));
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert(this mut &, u8 *position, char ch) -> (u8 mut *, usize)
  {
    return insert(this, position - this.begin, ch);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert(this mut &, usize position, char ch) -> (u8 mut *, usize)
  {
    var buf = [0; 8];
    var len = utf::encode(buf.data, ch);

    return insert(this, position, string_view(buf.data, len));
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert(this mut &, u8 *position, String &str) -> (u8 mut *, usize)
  {
    return insert(this, position - this.begin, str);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert(this mut &, usize position, String &str) -> (u8 mut *, usize)
  {
    var len = str.len;

    assert(position <= this._len);

    insert(this, position, str.data, str.len);

    return (this._data + position, len);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert<I>(this mut &, u8 *position, I first, Sentinal<I> last) -> (u8 mut *, usize)
  {
    return insert(this, position - this.begin, first, last);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn insert<I>(this mut &, usize position, I first, Sentinal<I> last) -> (u8 mut *, usize)
  {
    var index = position;

    while (first != last)
    {
      index += insert(this, index, *first++).1;
    }

    return (this._data + position, index - position);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn erase(this mut &, u8 *position, usize len) -> u8 mut *
  {
    return erase(this, first - this.begin, len);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn erase(this mut &, u8 *first, u8 *last) -> u8 mut *
  {
    return erase(this, first - this.begin, last - first);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn erase(this mut &, usize position, usize count) -> u8 mut *
  {
    assert(position <= this._len);

    if (this._len - position < count)
      count = this._len - position;

    memmove(this._data + position, this._data + position + count, this._len - position - count);

    this._len -= count;

    return this._data + position;
  }

  #[lifetime(poison(this), depend(this))]
  pub fn replace(this mut &, u8 *position, usize len, String &str) -> u8 mut *
  {
    return replace(this, position - this.begin, len, str);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn replace(this mut &, u8 *first, u8 *last, String &str) -> u8 mut *
  {
    return replace(this, first - this.begin, last - first, str);
  }

  #[lifetime(poison(this), depend(this))]
  pub fn replace(this mut &, usize position, usize count, String &str) -> u8 mut *
  {
    assert(position <= this._len);

    if (this._len - position < count)
      count = this._len - position;

    if (str.len < count)
    {
      memmove(this._data + position, str.data, str.len);

      erase(this, position + str.len, count - str.len);
    }
    else if (count < str.len)
    {
      memmove(this._data + position, str.data, count);

      insert(this, position + count, str.data + count, str.len - count);
    }
    else
    {
      memmove(this._data + position, str.data, str.len);
    }

    return this._data + position;
  }

  #[lifetime(poison(this), depend(this))]
  pub fn +=(this mut &, u8 ch) -> string mut &
  {
    if (this._len < this._capacity)
    {
      *(this._data + this._len++) = ch;
    }
    else
    {
      insert(this, this._len, ch);
    }

    return &this;
  }

  #[lifetime(poison(this), depend(this))]
  pub fn +=(this mut &, char ch) -> string mut &
  {
    if (this._len + 4 < this._capacity)
    {
      this._len += utf::encode(this._data + this._len, ch);
    }
    else
    {
      insert(this, this._len, ch);
    }

    return &this;
  }

  #[lifetime(poison(this), depend(this))]
  pub fn +=(this mut &, String &str) -> string mut &
  {
    insert(this, this._len, str.data, str.len);

    return &this;
  }

  #[lifetime(poison(this))]
  pub fn append(this mut &, var & ...args) -> usize
  {
    try
    {
      return std::print_to(this, args...);
    }
    catch(std::error e)
    {
      return 0;
    }
  }

  #[lifetime(poison(this))]
  pub fn appendf(this mut &, String &format, var & ...args) -> usize
  {
    try
    {
      return std::format_to(this, format, args...);
    }
    catch(std::error e)
    {
      return 0;
    }
  }

  #[lifetime(poison(this))]
  pub fn appendf(this mut &, #string_literal format, var & ...args) -> usize
  {
    try
    {
      return std::format_to(this, format, args...);
    }
    catch(std::error e)
    {
      return 0;
    }
  }

  #[lifetime(poison(this))]
  pub fn write(this mut &, u8 *data, usize len) -> usize
  {
    insert(this, this._len, data, len);

    return len;
  }

  fn init(this mut &)
  {
    this._len = 0;
    this._data = this._smallbuffer.data;
    this._capacity = this._smallbuffer.len;
  } 

  fn take<M>(this mut &, string<Allocator, M> mut &other) -> void
  {
    assert(this.empty);
    assert(this.allocator == other.allocator);

    if (other._data != other._smallbuffer.data)
    {
      swap(this._data, other._data);
      swap(this._len, other._len);
      swap(this._capacity, other._capacity);

      if (other._data == this._smallbuffer.data)
        other.init();
    }
    else
    {
      insert(this, this._len, other.data, other.len);

      other.clear();
    }
  }

  fn insert(this mut &, usize position, u8 *src, usize len) -> void
  {
    if (this._capacity < this._len + len)
    {
      var capacity = this._len + len;

      if (capacity < 2*this._capacity)
        capacity = 2*this._capacity;

      var data = cast<u8 mut *>(this._allocator.allocate(capacity, alignof<u8>));

      memcpy(data, this._data, position);
      memcpy(data + position, src, len);
      memcpy(data + position + len, this._data + position, this._len - position);

      swap(this._data, data);

      if (data != this._smallbuffer.data)
        this._allocator.free(data, this._capacity);

      this._capacity = capacity;
    }
    else
    {
      memmove(this._data + position + len, this._data + position, this._len - position);

      if (this._data <= src && src < this._data + this._len)
      {
        var cut = this._data + position;

        if (src < cut)
          memcpy(this._data + position, src, std::min(cut - src, len));

        if (src < cut && cut < src + len)
          memcpy(this._data + position + (cut - src), cut + len, len - (cut - src));

        if (cut <= src)
          memcpy(this._data + position, src + len, len);
      }
      else
      {
        memcpy(this._data + position, src, len);
      }
    }

    this._len += len;
  }

  usize _len;
  u8 mut *_data;

  usize _capacity;
  u8[N] _smallbuffer;

  Allocator _allocator;
}

pub fn +<Allocator, N>(string<Allocator, N> &&lhs, String &rhs) -> string<Allocator, N>
{
  var result = string<Allocator, N>(&&lhs, lhs.allocator);

  result += rhs;

  return result;
}

pub fn +<Allocator, N>(string<Allocator, N> &&lhs, u8 rhs) -> string<Allocator, N>
{
  var result = string<Allocator, N>(&&lhs, lhs.allocator);

  result += rhs;

  return result;
}

pub fn +<Allocator, N>(string<Allocator, N> &&lhs, char rhs) -> string<Allocator, N>
{
  var result = string<Allocator, N>(&&lhs, lhs.allocator);

  result += rhs;

  return result;
}

#[lifetime(poison(str))]
pub fn erase(string mut &str, u8 ch) -> usize
{
  var n = str.len;

  str.erase(std::remove(str.begin, str.end, ch), str.end);

  return n - str.len;
}

#[lifetime(poison(str))]
pub fn erase_if<Pred>(string mut &str, Pred &pred) -> usize
  where requires (u8 i, Pred &pred) { pred(i); }
{
  var n = str.len;

  str.erase(std::remove_if(str.begin, str.end, pred), str.end);

  return n - str.len;
}

pub fn hash(var &hasher, String &str) -> usize
{
  return hasher.combine_contiguous(str.data, str.len);
}

pub fn sprint<Args>(Span<u8> mut &os, Args & ...args) -> usize
{
  try
  {
    return std::format_to(os, args...);
  }
  catch(std::error e)
  {
    return 0;
  }
}

pub fn sprintf<Args>(Span<u8> mut &os, #string_literal format, Args & ...args) -> usize
{
  try
  {
    return std::format_to(os, format, args...);
  }
  catch(std::error e)
  {
    return 0;
  }
}

pub fn sprintf<Args>(Span<u8> mut &os, String &format, Args & ...args) -> usize
{
  try
  {
    return std::format_to(os, format, args...);
  }
  catch(std::error e)
  {
    return 0;
  }
}

#[lifetime(poison(str))]
pub fn sprint(string mut &str, var & ...args) -> usize
{
  return str.append(args...);
}

#[lifetime(poison(str))]
pub fn sprintf(string mut &str, String &format, var & ...args) -> usize
{
  return str.appendf(format, args...);
}

#[lifetime(poison(str))]
pub fn sprintf(string mut &str, #string_literal format, var & ...args) -> usize
{
  return str.appendf(format, args...);
}

#[lifetime(follow(str.data))]
pub fn chars(String &str)
{
  return string_view(str.data, str.len).chars;
}

#[lifetime(follow(str.data))]
pub fn lines(String &str)
{
  return string_view(str.data, str.len).lines;
}

#[lifetime(follow(str.data))]
pub fn words(String &str, String &delimiters = " \r\n\t")
{
  return string_view(str.data, str.len).words(delimiters);
}

#[lifetime(follow(str.data))]
pub fn split(String &str, String &seperator)
{
  return string_view(str.data, str.len).split(seperator);
}

#[lifetime(follow(str.data))]
pub fn split_after(String &str, String &seperator)
{
  return string_view(str.data, str.len).split_after(seperator);
}

#[lifetime(follow(str.data))]
pub fn split_n(String &str, usize n, String &seperator)
{
  return string_view(str.data, str.len).split_n(n, seperator);
}

#[lifetime(follow(str.data))]
pub fn split_after_n(String &str, usize n, String &seperator)
{
  return string_view(str.data, str.len).split_after_n(n, seperator);
}

#[lifetime(follow(haystack.data))]
pub fn find_first(String &&haystack, char needle)
{
  return find_first(&&haystack, haystack.begin, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_first(String &&haystack, u8 *pos, char needle)
{
  var n = pos - haystack.data;

  if (needle < 0x80)
    return haystack.data + n + memchr(haystack.data + n, cast<u8>(needle), haystack.len - n);

  var buf = [0; 8];
  var len = utf::encode(buf.data, needle);

  return find_first(&&haystack, pos, string_view(buf.data, len));
}

#[lifetime(follow(haystack.data))]
pub fn find_first(String &&haystack, String &needle)
{
  return find_first(&&haystack, haystack.begin, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_first(String &&haystack, u8 *pos, String &needle)
{
  var n = pos - haystack.data;

  if (needle.len == 0)
    return haystack.data + n;

  if (needle.len <= haystack.len - n)
  {
    for(var i = haystack.data + n, var end = haystack.end + 1 - needle.len; i != end; ++i)
    {
      if (memcmp(i, needle.data, needle.len) == 0)
        return i;
    }
  }

  return haystack.end;
}

#[lifetime(follow(haystack.data))]
pub fn find_first_of(String &&haystack, String &needle)
{
  return find_first_of(&&haystack, haystack.begin, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_first_of(String &&haystack, u8 *pos, String &needle)
{
  var n = pos - haystack.data;

  for(var i = haystack.data + n, var end = haystack.end; i != end; ++i)
  {
    for(var j = needle.begin; j != needle.end; )
    {
      var k = utf::len_next(j, needle.end);

      if (memcmp(i, j, k) == 0)
        return i;

      j += k;
    }
  }

  return haystack.end;
}

#[lifetime(follow(haystack.data))]
pub fn find_first_not_of(String &&haystack, String &needle)
{
  return find_first_not_of(&&haystack, haystack.begin, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_first_not_of(String &&haystack, u8 *pos, String &needle)
{
  var n = pos - haystack.data;

  for(var i = haystack.data + n, var end = haystack.end; i != end; ++i)
  {
    var found = true;
    for(var j = needle.begin; j != needle.end; )
    {
      var k = utf::len_next(j, needle.end);

      if (memcmp(i, j, k) == 0)
      {
        found = false;
        break;
      }

      j += k;
    }

    if (found)
      return i;
  }

  return haystack.end;
}

#[lifetime(follow(haystack.data))]
pub fn find_last(String &&haystack, char needle)
{
  return find_last(&&haystack, haystack.end, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_last(String &&haystack, u8 *pos, char needle)
{
  var n = pos - haystack.data;

  if (needle < 0x80)
    return haystack.data + memrchr(haystack.data, cast<u8>(needle), n);

  var buf = [0; 8];
  var len = utf::encode(buf.data, needle);

  return find_last(&&haystack, pos, string_view(buf.data, len));
}

#[lifetime(follow(haystack.data))]
pub fn find_last(String &&haystack, String &needle)
{
  return find_last(&&haystack, haystack.end, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_last(String &&haystack, u8 *pos, String &needle)
{
  var n = pos - haystack.data;

  if (needle.len == 0)
    return haystack.data + n;

  if (needle.len <= n)
  {
    rof(var i = haystack.data + n + 1 - needle.len, var end = haystack.data; i == end; --i)
    {
      if (memcmp(i, needle.data, needle.len) == 0)
        return i;
    }
  }

  return haystack.end;
}

#[lifetime(follow(haystack.data))]
pub fn find_last_of(String &&haystack, String &needle)
{
  return find_last_of(&&haystack, haystack.end, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_last_of(String &&haystack, u8 *pos, String &needle)
{
  var n = pos - haystack.data;

  rof(var i = haystack.data + n, var end = haystack.data; i == end; --i)
  {
    for(var j = needle.begin; j != needle.end; )
    {
      var k = utf::len_next(j, needle.end);

      if (memcmp(i, j, k) == 0)
        return i;

      j += k;
    }
  }

  return haystack.end;
}

#[lifetime(follow(haystack.data))]
pub fn find_last_not_of(String &&haystack, String &needle)
{
  return find_last_not_of(&&haystack, haystack.end, needle);
}

#[lifetime(follow(haystack.data))]
pub fn find_last_not_of(String &&haystack, u8 *pos, String &needle)
{
  var n = pos - haystack.data;

  rof(var i = haystack.data + n, var end = haystack.data; i == end; --i)
  {
    var found = true;
    for(var j = needle.begin; j != needle.end; )
    {
      var k = utf::len_next(j, needle.end);

      if (memcmp(i, j, k) == 0)
      {
        found = false;
        break;
      }

      j += k;
    }

    if (found)
      return i;
  }

  return haystack.end;
}

pub fn contains(String &haystack, u8 needle) -> bool
{
  return memchr(haystack.data, needle, haystack.len) != haystack.len;
}

pub fn contains(String &haystack, char needle) -> bool
{
  return find_first(haystack, needle) != haystack.end;
}

pub fn contains(String &haystack, String &needle) -> bool
{
  return find_first(haystack, needle) != haystack.end;
}

pub fn replace_first(string mut &str, u8 from, u8 to) -> bool
{
  var found = false;

  if (var i = memchr(str.begin, from, str._len); i != str._len)
  {
    str[i] = to;

    found = true;
  }

  return found;
}

#[lifetime(poison(str))]
pub fn replace_first(string mut &str, char from, char to) -> bool
{
  var from_buf = [0; 8];
  var from_len = utf::encode(from_buf.data, from);

  var to_buf = [0; 8];
  var to_len = utf::encode(to_buf.data, to);

  return replace_first(str, string_view(from_buf.data, from_len), string_view(to_buf.data, to_len));
}

#[lifetime(poison(str))]
pub fn replace_first(string mut &str, String &from, String &to) -> bool
{
  var found = false;

  if (from.len != 0)
  {
    if (var i = str.find_first(from); i != str.end)
    {
      str.replace(i, from.len, to);

      found = true;
    }
  }

  return found;
}

pub fn replace_all(string mut &str, u8 from, u8 to) -> usize
{
  var count = 0;

  while (var i = str.begin; i += memchr(i, from, str.end - i); i != str.end)
  {
    *i++ = to;

    count += 1;
  }

  return count;
}

#[lifetime(poison(str))]
pub fn replace_all(string mut &str, char from, char to) -> usize
{
  var from_buf = [0; 8];
  var from_len = utf::encode(from_buf.data, from);

  var to_buf = [0; 8];
  var to_len = utf::encode(to_buf.data, to);

  return replace_all(str, string_view(from_buf.data, from_len), string_view(to_buf.data, to_len));
}

#[lifetime(poison(str))]
pub fn replace_all(string mut &str, String &from, String &to) -> usize
{
  var count = 0;

  if (from.len != 0)
  {
    while (var i = str.begin; i = str.find_first(i, from); i != str.end)
    {
      i = str.replace(i, from.len, to) + to.len;

      count += 1;
    }
  }

  return count;
}

#[lifetime(follow(str.data))]
pub fn drop(String &str, usize n) -> string_view
{
  var i = str.chars.begin;

  for(; i != str.end; ++i)
  {
    if (n == 0)
      break;

    --n;
  }

  return string_view(i, str.end);
}

#[lifetime(poison(str))]
pub fn drop!(string mut &str, usize n) -> void
{
  str = drop(str, n);
}

#[lifetime(poison(str))]
pub fn drop_n!(string mut &str, usize n) -> void
{
  str = drop_n(str, n);
}

#[lifetime(follow(str.data))]
pub fn take(String &str, usize n) -> string_view
{
  var i = str.chars.begin;

  for(; i != str.end; ++i)
  {
    if (n == 0)
      break;

    --n;
  }

  return string_view(str.begin, i);
}

#[lifetime(poison(str))]
pub fn take!(string mut &str, usize n) -> void
{
  str = take(str, n);
}

#[lifetime(poison(str))]
pub fn take_n!(string mut &str, usize n) -> void
{
  str = take_n(str, n);
}

#[lifetime(follow(str.data))]
pub fn substr(String &str, usize i, usize n) -> string_view
{
  return str.drop(i).take(n);
}

#[lifetime(follow(str.data))]
pub fn trim_left(String &str) -> string_view
{
  var i = str.chars.begin;

  for(; i != str.end; ++i)
  {
    if (!is_whitespace(*i))
      break;
  }

  return string_view(i, str.end);
}

#[lifetime(follow(str.data))]
pub fn trim_right(String &str) -> string_view
{
  var j = str.end;

  rof(var i = str.chars.end; i == str.begin; --i)
  {
    if (!is_whitespace(*i))
      break;

    j = i;
  }

  return string_view(str.begin, j);
}

#[lifetime(follow(str.data))]
pub fn trim(String &str) -> string_view
{
  return trim_right(trim_left(str));
}

#[lifetime(poison(str))]
pub fn trim!(string mut &str) -> void
{
  str = trim(str);
}

pub fn starts_with(String &haystack, u8 needle) -> bool
{
  return !haystack.empty && *haystack.begin == needle;
}

pub fn starts_with(String &haystack, char needle) -> bool
{
  return !haystack.empty && *haystack.chars.begin == needle;
}

pub fn starts_with(String &haystack, String &needle) -> bool
{
  return haystack.len >= needle.len && haystack[0 .. needle.len] == needle;
}

pub fn ends_with(String &haystack, u8 needle) -> bool
{
  return !haystack.empty && *std::prev(haystack.end) == needle;
}

pub fn ends_with(String &haystack, char needle) -> bool
{
  return !haystack.empty && *std::prev(haystack.chars.end) == needle;
}

pub fn ends_with(String &haystack, String &needle) -> bool
{
  return haystack.len >= needle.len && haystack[haystack.len - needle.len .. haystack.len] == needle;
}

pub fn gsub(String &&str, u8 from, u8 to) -> string
{
  var str = string(&&str);
  str.replace_all(from, to);
  return str;
}

pub fn gsub(String &&str, char from, char to) -> string
{
  var str = string(&&str);
  str.replace_all(from, to);
  return str;
}

pub fn gsub(String &&str, String &from, String &to) -> string
{
  var str = string(&&str);
  str.replace_all(from, to);
  return str;
}

pub fn to_lowercase(String &&str) -> string
{
  var str = string(&&str);
  str.to_lowercase!;
  return str;
}

pub fn to_lowercase!(string mut &str) -> void
{
  for(var mut &ch : str)
    ch = to_lowercase(ch);
}

pub fn to_uppercase(String &&str) -> string
{
  var str = string(&&str);
  str.to_uppercase!;
  return str;
}

pub fn to_uppercase!(string mut &str) -> void
{
  for(var mut &ch : str)
    ch = to_uppercase(ch);
}

pub fn format(String &format, var & ...args) -> string
{
  var str = string();
  str.appendf(format, args...);
  return str;
}

pub fn format(#string_literal format, var & ...args) -> string
{
  var str = string();
  str.appendf(format, args...);
  return str;
}
