//
// std string
//

import std.span;
import std.stdlib : assert;
import std.algorithm : swap;
import std.memory : memcpy, memmove, memchr;
import std.range: Range;
import std.fmt;
import std.unicode;
import std.bits.utf as utf;

pub concept String
{
  requires<T> (T x) { x.len; };
  requires<T> (T x) { x.data; };
  requires<T> (T x) -> u8 { return *x.data; };
  requires<T> (T x) { x.begin; };
  requires<T> (T x) { x.end; };
}

pub using string_literal = typeof("");

pub struct string_view : std::span<u8>
{
  pub string_view(u8 *data, usize len)
    : super(data, len)
  {
  }

  pub string_view(u8 *beg, u8 *end)
    : super(beg, end)
  {
  }

  pub string_view(string_literal &str)
    : super(str.data, str.len)
  {
  }

  pub fn [](this&, (usize, usize) range) -> string_view
  {
    std::assert(range.0 <= range.1 && range.0 <= this.len && range.1 <= this.len);

    return string_view(this.data + range.0, this.data + range.1);
  }

  pub struct char_iterator : u8 *
  {
    pub char_iterator(char_iterator&) = default;
    pub ~char_iterator() = default;

    pub fn *(char_iterator &this) -> char
    {
      return this.codepoint;
    }

    pub fn ++(char_iterator mut &this) -> char_iterator mut &
    {
      this.super += this.n;

      this.n = 0;

      var state = 0;
      for(var ch = this.super; ch != this.end; ++ch)
      {
        this.n += 1;

        if (utf::decode(state, this.codepoint, *ch) == 0)
          break;
      }

      return &this;
    }

    pub fn --(char_iterator mut &this) -> char_iterator mut &
    {
      this.n = utf::len_last(this.beg, this.super);

      var state = 0;
      for(var ch = this.super - this.n; ch != this.super; ++ch)
      {
        utf::decode(state, this.codepoint, *ch);
      }

      this.super -= this.n;

      return &this;
    }

    pub fn -(u8 *rhs, char_iterator &lhs) -> usize = delete;

    pub fn ==(char_iterator &lhs, end_iterator rhs) -> bool
    {
      return lhs.n == 0;
    }

    pub fn len(char_iterator &this) -> usize
    {
      return this.n;
    }

    char_iterator(u8 *beg, u8 *end, u8 *cursor)
      : super(cursor), beg(beg), end(end)
    {
    }

    usize n;
    char codepoint;
    u8 *beg, u8 *end
  }

  pub struct line_iterator
  {
    pub line_iterator(line_iterator&) = default;
    pub ~line_iterator() = default;

    pub fn *(line_iterator &this) -> string_view
    {
      return string_view(this.cursor, this.m);
    }

    pub fn ++(line_iterator mut &this) -> line_iterator mut &
    {
      this.cursor += this.n;

      if (this.cursor != this.end)
      {
        this.n = std::memchr(this.cursor, cast('\n'), this.end - this.cursor);

        this.m = this.n;

        if (this.cursor + this.n != this.end)
        {
          if (this.m != 0 && *(this.cursor + this.m - 1) == cast('\r'))
            this.m -= 1;

          this.n += 1;
        }
      }
      else
      {
        this.n = this.m = 0;
      }

      return &this;
    }

    pub fn ==(line_iterator &lhs, u8 *rhs) -> bool
    {
      return lhs.cursor == rhs;
    }

    pub fn ==(line_iterator &lhs, line_iterator &rhs) -> bool
    {
      return lhs.cursor == rhs.cursor;
    }

    pub fn ==(line_iterator &lhs, end_iterator rhs) -> bool
    {
      return lhs.n == 0;
    }

    line_iterator(u8 *beg, u8 *end)
      : cursor(beg), end(end)
    {
    }

    usize n, usize m;
    u8 *cursor, u8 *end;
  }

  struct end_iterator
  {
    end_iterator() = default;
    end_iterator(end_iterator&) = default;
    fn =(end_iterator mut &this, end_iterator &that) -> end_iterator mut & = default;
    ~end_iterator() = default;
  }

  pub fn chars(this &) -> std::iterator_pair<char_iterator, char_iterator>
  {
    return std::iterator_pair(++char_iterator(this.begin, this.end, this.begin), char_iterator(this.begin, this.end, this.end));
  }

  pub fn lines(this &) -> std::iterator_pair<line_iterator, end_iterator>
  {
    return std::iterator_pair(++line_iterator(this.begin, this.end), end_iterator);
  }

  pub string_view(string_view &that) = default;
  pub ~string_view() = default;
}

pub fn String(string_literal &str) -> string_view
{
  return string_view(str.data, str.len);
}

pub struct string<Allocator = std::allocator, N = 24>
{
  pub string(Allocator &allocator = Allocator())
    : _allocator(allocator),
      _smallbuffer(void)
  {
    init(this);
  }
  
  pub string(String &&other, Allocator &allocator = Allocator())
    : _allocator(allocator),
      _smallbuffer(void)
  {
    init(this);

    #if (__is_rvalue<typeof(other)> && requires (typeof(this) this, typeof(other) other) { take(this, other); })
      this.take(other);
    #else
      this.write(other.data, other.len);
  }

  pub fn =(this mut &, String &&other) -> string mut &
  {
    if (this._data <= other.data && other.data < this._data + this._len)
    {
      memmove(this._data, other.data, other.len);
      this._len = other.len;
      return &this;
    }

    clear(this);

    #if (__is_rvalue<typeof(other)> && requires (typeof(this) this, typeof(other) other) { take(this, other); })
      this.take(other);
    #else
      this.write(other.data, other.len);

    return &this;
  }

  pub fn with_capacity(usize capacity, Allocator &allocator = Allocator()) -> string
  {
    var result = string(allocator);

    result.reserve(capacity);

    return result;
  }

  pub fn from_utf8(u8 *data, usize len, Allocator &allocator = Allocator()) -> string
  {
    return string(string_view(data, len), allocator);
  }

  pub fn from_utf8(u8 *beg, u8 *end, Allocator &allocator = Allocator()) -> string
  {
    return string(string_view(beg, end), allocator);
  }

  pub ~string()
  {
    this._len = 0;

    if (_data != _smallbuffer.data)
      this._allocator.free(_data, _capacity);
  }
  
  pub fn len(this &) -> usize
  {
    return this._len;
  }
  
  pub fn empty(this &) -> bool
  {
    return this._len == 0;
  }
  
  pub fn capacity(this &) -> usize
  {
    return this._capacity;
  }

  pub fn data(this &&)
  {
    return this._data;
  }

  pub fn allocator(this &) -> Allocator &
  {
    return &this._allocator;
  }

  pub fn [](this &&, usize index)
  {
    assert(index < this.len);

    return &*(this.data + index);
  }

  pub fn [](this &, (usize, usize) range) -> string_view
  {
    assert(range.0 <= range.1 && range.0 <= this.len && range.1 <= this.len);

    return string_view(this.data + range.0, this.data + range.1);
  }

  pub fn begin(this &&)
  {
    return this._data;
  }

  pub fn end(this &&)
  {
    return this._data + this._len;
  }

  pub fn reserve(this mut &, usize capacity) -> void
  {
    if (this._capacity < capacity)
    {
      var data = cast<u8 mut *>(this._allocator.allocate(capacity, alignof<u8>));
      
      memcpy(data, this._data, this._len);
      swap(this._data, data);
      swap(this._capacity, capacity);

      if (data != this._smallbuffer.data)
        this._allocator.free(data, capacity);
    }
  }

  pub fn resize(this mut &, usize size) -> void
  {
    reserve(this, size);

    this._len = size;
  }

  pub fn clear(this mut &) -> void
  {
    if (this._data != this._smallbuffer.data)
      this._allocator.free(this._data, this._capacity);

    this.init();
  }

  pub fn append(this mut &, var & ...args) -> usize
  {
    try
    {
      return std::print_to(this, args...);
    }
    catch(std::error e)
    {
      return 0;
    }
  }

  pub fn appendf(this mut &, String &format, var & ...args) -> usize
  {
    ensure_capacity(this, this._len + format.len);

    try
    {
      return std::format_to(this, format, args...);
    }
    catch(std::error e)
    {
      return 0;
    }
  }

  pub fn appendf(this mut &, #std::string_literal format, var & ...args) -> usize
  {
    ensure_capacity(this, this._len + format.len);

    try
    {
      return std::format_to(this, format, args...);
    }
    catch(std::error e)
    {
      return 0;
    }
  }

  pub fn write(this mut &, u8 *data, usize len) -> usize
  {
    ensure_capacity(this, this._len + len);

    memcpy(this._data + this._len, data, len);

    this._len += len;

    return len;
  }

  fn init(this mut &)
  {
    this._len = 0;
    this._data = this._smallbuffer.data;
    this._capacity = this._smallbuffer.len;
  } 

  fn ensure_capacity(this mut &, usize len) -> void
  {
    if (len <= this._capacity)
      return;

    if (len < 2*this._capacity)
      len = 2*this._capacity;

    reserve(this, len);
  }

  fn take<M>(this mut &, string<Allocator, M> mut &other) -> void
  {
    assert(this.empty);
    assert(this.allocator == other.allocator);

    if (other._data != other._smallbuffer.data)
    {
      swap(this._data, other._data);
      swap(this._len, other._len);
      swap(this._capacity, other._capacity);

      if (other._data == this._smallbuffer.data)
        other.init();
    }
    else
    {
      write(this, other.data, other.len);

      other.clear();
    }
  }

  usize _len;
  u8 mut *_data;

  usize _capacity;
  u8[N] _smallbuffer;

  Allocator _allocator;
}

pub fn sprint(string mut &str, var & ...args) -> usize
{
  str.clear();

  return str.append(args...);
}

pub fn sprintf(string mut &str, String &format, var & ...args) -> usize
{
  str.clear();

  return str.appendf(format, args...);
}

pub fn sprintf(string mut &str, #std::string_literal format, var & ...args) -> usize
{
  str.clear();

  return str.appendf(format, args...);
}

pub fn chars(String &str)
{
  return string_view(str.data, str.len).chars;
}

pub fn lines(String &str)
{
  return string_view(str.data, str.len).lines;
}

pub fn find(String &&haystack, char needle)
{
  // TODO: unicode
  return haystack.data + memchr(haystack.data, cast<u8>(needle), haystack.len);
}

pub fn trim_left(String &str) -> string_view
{
  var i = str.chars.begin;

  for(; i != str.end; ++i)
  {
    if (!std::is_whitespace(*i))
      break;
  }

  return std::string_view(i, str.end);
}

pub fn trim_right(String &str) -> string_view
{
  var j = str.end;

  rof(var i = str.chars.end; i == str.begin; --i)
  {
    if (!std::is_whitespace(*i))
      break;

    j = i;
  }

  return std::string_view(str.begin, j);
}

pub fn trim(String &str) -> string_view
{
  return trim_right(trim_left(str));
}
