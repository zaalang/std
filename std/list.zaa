//
// std list
//

import std.memory;
import std.stdlib : assert;
import std.algorithm : swap;
import std.range : Sentinal, Range;
import std.type : as_const;

pub struct list<T, Allocator = std::allocator>
{
  pub list(Allocator &allocator = Allocator())
    : _allocator(allocator)
  {
    init(this);
  }

  pub list(list &&other, Allocator &allocator = Allocator())
    : _allocator(allocator)
  {
    init(this);

    insert(this, this.end, &&other);
  }

  #[lifetime(poison(this))]
  pub fn =(this mut &, list &&other) -> list mut &
  {
    if (&this != &other)
    {
      clear(this);

      insert(this, this.end, &&other);
    }

    return &this;
  }

  pub fn with_size(usize size, Allocator &allocator = Allocator()) -> list
  {
    var result = list(allocator);

    result.resize(size);

    return result;
  }

  pub fn from(Range<T> &&other, Allocator &allocator = Allocator()) -> list
  {
    var result = list(allocator);

    insert(result, result.end, &&other);

    return result;
  }

  pub fn from<U>(Range<U> &&other, Allocator &allocator = Allocator()) -> list
    match (U u) { T(u, allocator?: std::declval<Allocator>()); }
    where !__is_same<U, T>
  {
    var result = list(allocator);

    insert(result, result.end, &&other);

    return result;
  }

  pub ~list()
  {
    clear(this);
  }

  pub fn len(this &) -> usize
  {
    return this._len;
  }

  pub fn empty(this &) -> bool
  {
    return this._len == 0;
  }

  pub fn allocator(this &) -> Allocator &
  {
    return &this._allocator;
  }

  pub struct iterator
  {
    pub iterator() = default;
    pub iterator(iterator&) = default;
    pub fn =(iterator mut &this, iterator &that) -> iterator mut & = default;
    pub ~iterator() = default;

    #[lifetime(clone(this))]
    pub fn ++(iterator mut &this) -> iterator mut &
    {
      this.cursor = this.cursor.next;
      return &this;
    }

    #[lifetime(clone(this))]
    pub fn --(iterator mut &this) -> iterator mut &
    {
      this.cursor = this.cursor.prev;
      return &this;
    }

    iterator(Link *node)
      : cursor(node)
    {
    }

    Link *cursor;
  }

  pub fn ==(iterator &lhs, iterator &rhs) -> bool
  {
    return lhs.cursor == rhs.cursor;
  }

  #[lifetime(depend(this))]
  pub fn begin(this &)
  {
    return iterator(this._root.next);
  }

  #[lifetime(depend(this))]
  pub fn end(this &)
  {
    return iterator(&this._root);
  }

  #[lifetime(depend(this))]
  pub fn [](this &&, iterator iter)
  {
    return &cast<&&typeof(this)>(cast<Node mut *>(iter.cursor).value);
  }

  #[lifetime(depend(this))]
  pub fn front(this &&)
  {
    assert(this._len != 0);

    return &cast<&&typeof(this)>(cast<Node mut *>(this._root.next).value);
  }

  #[lifetime(depend(this))]
  pub fn back(this &&)
  {
    assert(this._len != 0);

    return &cast<&&typeof(this)>(cast<Node mut *>(this._root.prev).value);
  }

  #[lifetime(depend(this))]
  pub fn push_front<Args>(this mut &, Args && ...args) -> T mut &
    match (Args args) { T(args..., allocator?: std::declval<Allocator>()); }
  {
    return &insert(this, this.begin.cursor, &&args...).value;
  }

  #[lifetime(depend(this))]
  pub fn push_back<Args>(this mut &, Args && ...args) -> T mut &
    match (Args args) { T(args..., allocator?: std::declval<Allocator>()); }
  {
    return &insert(this, this.end.cursor, &&args...).value;
  }

  #[lifetime(depend(this))]
  pub fn insert<Args>(this mut &, iterator position, Args && ...args) -> iterator
    match (Args args) { T(args..., allocator?: std::declval<Allocator>()); }
  {
    return iterator(insert(this, position.cursor, &&args...));
  }

  #[lifetime(depend(this))]
  pub fn insert<U>(this mut &, iterator position, Range<U> &&other) -> iterator
    match (U u) { T(u, allocator?: std::declval<Allocator>()); }
  {
    #if (__is_rvalue<typeof(other)> && __is_same<list, typeof(other)>)
    {
      return this.splice(position, other);
    }

    var node = cast<Node mut *>(position.cursor);

    if (var first = other.begin, var last = other.end; first != last)
    {
      node = insert(this, position.cursor, (&&other)[first++]);

      while (first != last)
      {
        insert(this, position.cursor, (&&other)[first++]);
      }
    }

    return iterator(node);
  }

  #[lifetime(depend(this))]
  pub fn insert<I>(this mut &, iterator position, I first, Sentinal<I> last) -> iterator
    where requires (I i) { T(*i); }
  {
    var node = cast<Node mut *>(position.cursor);

    if (first != last)
    {
      node = insert(this, position.cursor, *first++);

      while (first != last)
      {
        insert(this, position.cursor, *first++);
      }
    }

    return iterator(node);
  }

  #[lifetime(depend(this))]
  pub fn append<U>(this mut &, Range<U> &&other) -> iterator
    match (U u) { T(u, allocator?: std::declval<Allocator>()); }
  {
    return insert(this, this.end, &&other);
  }

  #[lifetime(depend(this))]
  pub fn append<I>(this mut &, I first, Sentinal<I> last) -> iterator
    where requires (I i) { T(*i); }
  {
    return insert(this, this.end, first, last);
  }

  #[lifetime(depend(this))]
  pub fn splice(this mut &, iterator position, list mut &other) -> iterator
  {
    assert(&this != &other);
    assert(this.allocator == other.allocator);

    var x = cast<Link mut *>(position.cursor);

    if (other.len != 0)
    {
      x = splice(this, position.cursor, other, other.begin.cursor, other.end.cursor, other.len);
    }

    return iterator(x);
  }

  #[lifetime(depend(this))]
  pub fn splice(this mut &, iterator position, list mut &other, iterator first) -> iterator
  {
    assert(this.allocator == other.allocator);

    var x = cast<Link mut *>(position.cursor);

    if (first != other.end)
    {
      x = splice(this, position.cursor, other, first.cursor, first.cursor.next, 1);
    }

    return iterator(x);
  }

  #[lifetime(depend(this))]
  pub fn splice(this mut &, iterator position, list mut &other, iterator first, iterator last) -> iterator
  {
    assert(this.allocator == other.allocator);

    var x = cast<Link mut *>(position.cursor);

    if (first != last)
    {
      x = splice(this, position.cursor, other, first.cursor, last.cursor, std::distance(first, last));
    }

    return iterator(x);
  }

  #[lifetime(poison(this))]
  pub fn pop_front(this mut &) -> void
  {
    assert(!this.empty);
    
    erase(this, this._root.next, this._root.next.next);
  }

  #[lifetime(poison(this))]
  pub fn pop_back(this mut &) -> void
  {
    assert(!this.empty);

    erase(this, this._root.prev, this._root.prev.next);
  }
  
  #[lifetime(poison(this))]
  pub fn take_front(this mut &) -> T
  {
    var result = std::move(std::launder(this.front));

    pop_front(this);

    return result;
  }

  #[lifetime(poison(this))]
  pub fn take_back(this mut &) -> T
  {
    var result = std::move(std::launder(this.back));

    pop_back(this);

    return result;
  }

  #[lifetime(poison(this), depend(this))]
  pub fn erase(this mut &, iterator position) -> iterator
  {
    if (position == this.end)
      return iterator(position);

    return iterator(erase(this, position.cursor, position.cursor.next));
  }

  #[lifetime(poison(this), depend(this))]
  pub fn erase(this mut &, iterator first, iterator last) -> iterator
  {
    return iterator(erase(this, first.cursor, last.cursor));
  }

  #[lifetime(poison(this), depend(this))]
  pub fn drop_n!(this mut &, usize n) -> list mut &
  {
    erase(this, this.begin, std::next(this.begin, n, this.end));

    return &this;
  }

  #[lifetime(poison(this), depend(this))]
  pub fn take_n!(this mut &, usize n) -> list mut &
  {
    erase(this, std::next(this.begin, n, this.end), this.end);

    return &this;
  }

  pub fn resize(this mut &, usize size) -> void
  {
    while (size < this._len)
      this.pop_back();

    while (this._len < size)
      this.push_back();
  }

  #[lifetime(poison(this))]
  pub fn clear(this mut &) -> void
  {
    erase(this, this._root.next, &this._root);
  }
  
  struct Link
  {
    Link mut *next;
    Link mut *prev;

    Link() = default;
    ~Link() = default;
  }

  struct Node : Link
  {
    Node()
      : value(void)
    {
    }

    ~Node() = default;

    T value;
  }

  fn init(this mut &)
  {
    this._len = 0;
    this._root.next = this._root.prev = &this._root;
  }

  fn insert<Args>(this mut &, Link *position, Args && ...args) -> Node mut *
  {
    var node = new<Node>(this._allocator.allocate(sizeof<Node>, alignof<Node>));

    new<T>(&node.value)(&&args..., allocator?: this.allocator);

    node.next = cast(position);
    node.prev = cast(position.prev);
    node.next.prev = node.prev.next = node;

    this._len += 1;
    
    return node;
  }

  fn splice(this mut &, Link *position, list mut &other, Link *first, Link *last, usize count) -> Link mut *
  {
    var node = cast<Link mut *>(first);
    var last = cast<Link mut *>(last.prev);

    last.next.prev = node.prev;
    node.prev.next = last.next;

    last.next = cast(position);
    node.prev = cast(position.prev);
    last.next.prev = last;
    node.prev.next = node;

    this._len += count;
    other._len -= count;

    return node;
  }

  fn erase(this mut &, Link *first, Link *last) -> Link mut *
  {
    var count = 0;
    var node = cast<Link mut *>(first);
    var prev = cast<Link mut *>(first.prev);
    var last = cast<Link mut *>(last);

    while (node != last)
    {
      var next = node.next;

      Node::~Node(*cast<Node mut *>(node));
      this._allocator.free(node, sizeof<Node>);

      count += 1;
      node = next;
    }

    prev.next = last;
    last.prev = prev;

    this._len -= count;

    return node;
  }

  Link _root;
  usize _len;

  Allocator _allocator;
}

pub fn hash<T>(var &hasher, list<T> &lst) -> usize
{
  return hasher.combine_range(lst, lst.begin, lst.end);
}

#[lifetime(poison(lst))]
pub fn erase<T, Value>(list<T> mut &lst, Value &value) -> usize
  match (Value value) { T(value); }
{
  var n = lst.len;
  var first = lst.begin;

  for (; first != lst.end; )
  {
    if (lst[first] == value)
      first = lst.erase(first);
    else
      ++first;
  }

  return n - lst.len;
}

#[lifetime(poison(lst))]
pub fn erase_if<T, Pred>(list<T> mut &lst, Pred &pred) -> usize
  where requires (T i, Pred &pred) { pred(i); }
{
  var n = lst.len;
  var first = lst.begin;

  for (; first != lst.end; )
  {
    if (pred(lst[first]))
      first = lst.erase(first);
    else
      ++first;
  }

  return n - lst.len;
}
