//
// std iterator
//

import std.stdlib;

pub concept Iterator
{
  requires<T> (T x) { *x; };
  requires<T> (T x) { ++x; };
  requires<T> (T x, T y) { x == y; };
}

pub concept RandomAccessIterator
{
  requires<T> __is_match<Iterator, T>;
  requires<T> (T x, T y) { x - y; };
  requires<T> (T x, usize y) { x + y; };
}

pub concept Sentinal<I>
{
  requires<T> (T x, I y) { y == x; };
}

pub struct move_iterator<I>
{
  I base;

  pub move_iterator(I base)
    : base(base)
  {
  }

  pub move_iterator() = default;
  pub move_iterator(move_iterator &&) = default;
  pub fn =(move_iterator mut &, move_iterator &) -> move_iterator mut & = default;
  pub ~move_iterator() = default;

  pub fn *(move_iterator &&this)
  {
    return &std::move(*this.base);
  }

  pub fn ++(move_iterator mut &this) -> move_iterator mut &
  {
    ++this.base;
    return &this;
  }

  pub fn --(move_iterator mut &this) -> move_iterator mut &
  {
    --this.base;
    return &this;
  }
}

pub fn ==<I, J>(move_iterator<I> &lhs, move_iterator<J> &rhs) -> bool
{
  return lhs.base == rhs.base;
}

pub fn -<I, J>(move_iterator<I> lhs, move_iterator<J> rhs) -> usize
  where requires (I i, J j) { i - j; }
{
  return lhs.base - rhs.base;
}

pub fn -<I>(move_iterator<I> lhs, usize rhs) -> move_iterator<I>
  where requires (I i, usize j) { i - j; }
{
  return move_iterator<I>(lhs.base - rhs);
}

pub fn +<I>(move_iterator<I> lhs, usize rhs) -> move_iterator<I>
  where requires (I i, usize j) { i + j; }
{
  return move_iterator<I>(lhs.base + rhs);
}

pub struct iterator_pair<I, J>
{
  pub I first;
  pub J second;

  pub iterator_pair(I first, J second)
    : first(first), second(second)
  {
  }

  pub iterator_pair() = default;
  pub iterator_pair(iterator_pair &&) = default;
  pub fn =(iterator_pair mut &, iterator_pair &) -> iterator_pair mut & = default;
  pub ~iterator_pair() = default;

  pub fn begin(this &&)
  {
    return this.first;
  }

  pub fn end(this &&)
  {
    return this.second;
  }
}

pub fn next(Iterator i, usize n = 1) -> typeof(i)
{
  #if (requires (typeof(i) x, usize y) { x + y; })
  {
    return i + n;
  }
  #else
  {
    while (n != 0)
    {
      ++i;
      --n;
    }

    return i;
  }
}

pub fn prev(Iterator i, usize n = 1) -> typeof(i)
{
  #if (requires (typeof(i) x, usize y) { x - y; })
  {
    return i - n;
  }
  #else
  {
    while (n != 0)
    {
      --i;
      --n;
    }

    return i;
  }
}
