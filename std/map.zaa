//
// std map
//

import std.memory;
import std.stdlib : assert;
import std.algorithm : swap;
import std.range : Sentinal, Range;
import std.tuple : tuple;
import std.type : as_const;

pub struct map<K, T, Cmp = typeof(std::less), Allocator = std::allocator>
{
  pub struct value_type
  {
    K const key;
    T value;

    value_type<Key, Args>(Key &&key, Args && ...args, Allocator &allocator = Allocator())
      : key(&&key, allocator?: allocator), value(&&args..., allocator?: allocator)
    {
    }

    value_type(value_type &&, Allocator &allocator = Allocator()) = default;
    fn =(this mut &, value_type &&) -> value_type mut & = default;

    ~value_type() = default;
  }

  map(Allocator &allocator = Allocator())
    : allocator(allocator)
  {
    init(this);
  }

  map(Cmp &&cmp, Allocator &allocator = Allocator())
    where requires (Cmp cmp, K i, K j) { cmp(i, j); }
    : cmp(&&cmp), allocator(allocator)
  {
    init(this);
  }

  map(map &&other, Allocator &allocator = Allocator())
    : cmp(&&other.cmp), allocator(allocator)
  {
    init(this);

    insert(this, &&other);
  }

  pub fn =(this mut &, map &&other) -> map mut &
  {
    if (&this == &other)
      return &this;

    clear(this);

    this.cmp = &&other.cmp;

    insert(this, &&other);

    return &this;
  }

  pub fn from(Range<value_type> &&other, Allocator &allocator = Allocator()) -> map
  {
    var result = map(allocator);

    result.insert(&&other);

    return result;
  }

  ~map()
  {
    clear(this);
  }

  pub fn len(this &) -> usize
  {
    return this._len;
  }

  pub fn empty(this &) -> bool
  {
    return this._len == 0;
  }

  pub struct iterator
  {
    iterator() = default;
    iterator(iterator&) = default;
    fn =(iterator mut &this, iterator &that) -> iterator mut & = default;
    ~iterator() = default;

    iterator(Link mut *node)
      : cursor(node)
    {
    }

    fn *(iterator &this) -> value_type &
    {
      return &cast<Node*>(this.cursor).value;
    }

    fn *(iterator mut &this) -> value_type mut &
    {
      return &cast<Node mut *>(this.cursor).value;
    }

    fn ++(iterator mut &this) -> iterator mut &
    {
      this.cursor = this.cursor.next;
      return &this;
    }

    fn --(iterator mut &this) -> iterator mut &
    {
      this.cursor = this.cursor.prev;
      return &this;
    }

    Link mut *cursor;
  }

  pub struct move_iterator
  {
    move_iterator() = default;
    move_iterator(move_iterator&) = default;
    fn =(move_iterator mut &this, move_iterator &that) -> move_iterator mut & = default;
    ~move_iterator() = default;

    move_iterator(Link mut *node)
      : cursor(node)
    {
    }

    fn *(move_iterator &this) -> value_type &
    {
      return &cast<Node*>(this.cursor).value;
    }

    fn *(move_iterator mut &this) -> value_type &&
    {
      return &std::move(cast<Node mut *>(this.cursor).value);
    }

    fn ++(move_iterator mut &this) -> move_iterator mut &
    {
      this.cursor = this.cursor.next;
      return &this;
    }

    fn --(move_iterator mut &this) -> move_iterator mut &
    {
      this.cursor = this.cursor.prev;
      return &this;
    }

    Link mut *cursor;
  }

  pub struct const_iterator
  {
    const_iterator() = default;
    const_iterator(const_iterator&) = default;
    fn =(const_iterator mut &this, const_iterator &that) -> const_iterator mut & = default;
    ~const_iterator() = default;

    const_iterator(Link *node)
      : cursor(node)
    {
    }

    const_iterator(iterator other)
      : cursor(other.cursor)
    {
    }

    fn *(const_iterator &this) -> value_type &
    {
      return &cast<Node*>(this.cursor).value;
    }

    fn ++(const_iterator mut &this) -> const_iterator mut &
    {
      this.cursor = this.cursor.next;
      return &this;
    }

    fn --(const_iterator mut &this) -> const_iterator mut &
    {
      this.cursor = this.cursor.prev;
      return &this;
    }

    Link *cursor;
  }

  pub concept Iterator
  {
    requires<T> __is_same<T, iterator> || __is_same<T, move_iterator> || __is_same<T, const_iterator>;
  }

  pub fn key(Iterator &this)
  {
    return &(*this).key;
  }

  pub fn value(Iterator &&this)
  {
    return &(*this).value;
  }

  pub fn ==(Iterator &lhs, Iterator &rhs) -> bool
  {
    return lhs.cursor == rhs.cursor;
  }

  fn iter(this &&, var node)
  {
    #if (__is_const<typeof(this)>)
      return const_iterator(node);

    #else if (__is_rvalue<typeof(this)>)
      return move_iterator(node);

    #else
      return iterator(node);
  }

  pub fn begin(this &&)
  {
    return iter(&&this, this._leftmost);
  }

  pub fn end(this &&)
  {
    return iter(&&this, &this._root);
  }

  pub fn lower_bound<Key>(this &&, Key &key)
  {
    var x = this._root.parent;
    var y = &this._root;

    while (x)
    {
      if (!this.cmp(cast<Node*>(x).value.key, key))
      {
        y = x;
        x = x.left;
      }
      else
      {
        x = x.right;
      }
    }

    return iter(&&this, y);
  }

  pub fn upper_bound<Key>(this &&, Key &key)
  {
    var x = this._root.parent;
    var y = &this._root;

    while (x)
    {
      if (this.cmp(key, cast<Node*>(x).value.key))
      {
        y = x;
        x = x.left;
      }
      else
      {
        x = x.right;
      }
    }

    return iter(&&this, y);
  }

  pub fn equal_range<Key>(this &&, Key &key)
  {
    var x = this._root.parent;
    var y = &this._root;

    while (x)
    {
      if (this.cmp(key, cast<Node*>(x).value.key))
      {
        y = x;
        x = x.left;
      }
      else if (this.cmp(cast<Node*>(x).value.key, key))
      {
        x = x.right;
      }
      else
      {
        return std::iterator_pair(iter(&&this, x), ++iter(&&this, x));
      }
    }

    return std::iterator_pair(iter(&&this, y), iter(&&this, y));
  }

  pub fn find<Key>(this &&, Key &key)
  {
    var x = lower_bound(&&this, key);

    if (x == this.end || this.cmp(key, x.key))
      return (&&this).end;

    return x;
  }

  pub fn contains<Key>(this &, Key &key) -> bool
  {
    return this.find(key) != this.end;
  }

  pub fn insert(this mut &, value_type &&value) -> (iterator, bool)
  {
    var pos = find_insert_position(this, value.key);

    if (pos.1)
    {
      pos.0 = add_node(this, pos.1, &&value);
    }

    return tuple(iterator(pos.0), !!pos.1);
  }

  pub fn insert<Key, Args>(this mut &, Key &&key, Args && ...args) -> (iterator, bool)
    match (Key key, Args args) { K(key, allocator?: std::declval<Allocator>()); T(args..., allocator?: std::declval<Allocator>()); }
  {
    var pos = find_insert_position(this, key);

    if (pos.1)
    {
      pos.0 = add_node(this, pos.1, &&key, &&args...);
    }

    return tuple(iterator(pos.0), !!pos.1);
  }

  pub fn insert(this mut &, Range<value_type> &&other) -> void
  {
    #if (__is_rvalue<typeof(other)> && __is_same<map, typeof(other)>)
    {
      if (this.empty)
        return this.take(other);

      return this.merge(other);
    }

    #if (__is_rvalue<typeof(other)> && __is_array<typeof(other)>)
    {
      return this.insert(std::move_iterator(other.begin), std::move_iterator(other.end));
    }

    return this.insert((&&other).begin, (&&other).end);
  }

  pub fn insert<I>(this mut &, I first, Sentinal<I> last) -> void
  {
    while (first != last)
    {
      this.insert(*first++);
    }
  }

  pub fn merge(this mut &, map mut &other) -> void
  {
    assert(&this != &other);
    assert(this.allocator == other.allocator);

    std::panic("not implemented");
  }

  pub fn erase<Key>(this mut &, Key &key) -> usize
  {
    var x = this.find(key);

    if (x == this.end)
      return 0;

    erase_nodes(this, x.cursor, x.cursor.next);

    return 1;
  }

  pub fn erase(this mut &, Iterator position) -> iterator
  {
    return iterator(erase_nodes(this, position.cursor, position.cursor.next));
  }

  pub fn erase(this mut &, Iterator first, Iterator last) -> iterator
  {
    return iterator(erase_nodes(this, first.cursor, last.cursor));
  }

  pub fn clear(this mut &) -> void
  {
    destroy_nodes(this, this._root.parent);

    init(this);
  }

  struct Link
  {
    enum Color { red, black }

    Color color;
    Link mut *parent;
    Link mut *left;
    Link mut *right;

    Link() = default;
    ~Link() = default;
  }

  struct Node : Link
  {
    Node()
      : value(void)
    {
    }

    ~Node() = default;

    value_type value;
  }

  fn init(this mut &)
  {
    this._len = 0;
    this._root.color = Link::Color::red;
    this._root.parent = null;
    this._root.left = &this._root;
    this._leftmost = &this._root;
  }

  fn take(this mut &, map mut &other) -> void
  {
    assert(this.empty);
    assert(this.allocator == other.allocator);

    if (!other.empty)
    {
      this._root.parent = other._root.parent;
      this._root.parent.parent = &this._root;
      this._root.left = other._root.left;
      this._leftmost = other._leftmost;
    }

    swap(this._len, other._len);
    swap(this.cmp, other.cmp);

    other.init();
  }

  fn add_node<Args>(this mut &, Link mut *parent, Args && ...args) -> Node mut *
  {
    var node = new<Node>(this.allocator.allocate(sizeof<Node>, alignof<Node>));

    new<value_type>(&node.value)(&&args..., allocator?: this.allocator);

    node.parent = parent;

    if (parent == &this._root)
    {
      this._root.parent = node;
      this._root.left = node;
      this._leftmost = node;
    }
    else if (this.cmp(node.value.key, cast<Node*>(parent).value.key))
    {
      parent.left = node;

      if (parent == this._leftmost)
        this._leftmost = node;
    }
    else
    {
      parent.right = node;

      if (parent == this._root.left)
        this._root.left = node;
    }

    tree_balance_after_insert(this._root.parent, node);

    this._len += 1;

    return node;
  }

  fn erase_nodes(this mut &, Link *first, Link *last) -> Node mut *
  {
    var count = 0;
    var node = cast<Node mut *>(first);
    var last = cast<Link mut *>(last);

    while (node != last)
    {
      var next = cast<Node mut *>(node.next);

      if (node == this._leftmost)
        this._leftmost = next;

      if (node == this._root.left)
        this._root.left = node.prev;

      tree_balance_for_erase(this._root.parent, node);

      Node::~Node(*node);
      this.allocator.free(node, sizeof<Node>);

      count += 1;
      node = next;
    }

    this._len -= count;

    return node;
  }

  fn destroy_nodes(this mut &, Link mut *node) -> void
  {
    var node = cast<Node mut *>(node);

    if (node)
    {
      destroy_nodes(this, node.left);
      destroy_nodes(this, node.right);

      Node::~Node(*node);
      this.allocator.free(node, sizeof<Node>);
    }
  }

  fn find_insert_position<Key>(this mut &, Key &key) -> (Link mut *, Link mut *)
  {
    var x = this._root.parent;
    var y = &this._root;
    var v = true;

    while (x)
    {
      y = x;
      v = this.cmp(key, cast<Node*>(x).value.key);
      x = v ? x.left : x.right;
    }

    if (v || this.cmp(cast<Node*>(y).value.key, key))
      return tuple(null, y);

    return tuple(y, null);
  }

  fn next(Link &&link)
  {
    var x = &link;

    if (x.right)
    {
      x = x.right;

      while (x.left)
        x = x.left;
    }
    else
    {
      while (x == x.parent.right)
        x = x.parent;

      x = x.parent;
    }

    return x;
  }

  fn prev(Link &&link)
  {
    var x = &link;

    if (x.left)
    {
      x = x.left;

      while (x.right)
        x = x.right;
    }
    else
    {
      while (x == x.parent.left)
        x = x.parent;

      x = x.parent;
    }

    return x;
  }

  Link _root;
  Link mut *_leftmost;
  usize _len;

  Cmp cmp;
  Allocator allocator;
}

fn tree_rotate_left<K, T, Cmp, Allocator>(map<K, T, Cmp, Allocator>::Link mut * mut &root, map<K, T, Cmp, Allocator>::Link mut *x) -> void
{
  var y = x.right;

  x.right = y.left;

  if (x.right)
    x.right.parent = x;

  y.parent = x.parent;

  if (x == root)
    root = y;
  else if (x == x.parent.left)
    x.parent.left = y;
  else
    x.parent.right = y;

  y.left = x;
  x.parent = y;
}

fn tree_rotate_right<K, T, Cmp, Allocator>(map<K, T, Cmp, Allocator>::Link mut * mut &root, map<K, T, Cmp, Allocator>::Link mut *x) -> void
{
  var y = x.left;

  x.left = y.right;

  if (x.left)
    x.left.parent = x;

  y.parent = x.parent;

  if (x == root)
    root = y;
  else if (x == x.parent.right)
    x.parent.right = y;
  else
    x.parent.left = y;

  y.right = x;
  x.parent = y;
}

fn tree_balance_after_insert<K, T, Cmp, Allocator>(map<K, T, Cmp, Allocator>::Link mut * mut &root, map<K, T, Cmp, Allocator>::Link mut *x) -> void
{
  using Color = map<K, T, Cmp, Allocator>::Link::Color;

  while (x != root && x.parent.color == Color::red)
  {
    var xpp = x.parent.parent;

    if (x.parent == xpp.left)
    {
      var y = xpp.right;

      if (y && y.color == Color::red)
      {
        x.parent.color = Color::black;
        y.color = Color::black;
        xpp.color = Color::red;
        x = xpp;
      }
      else
      {
        if (x == x.parent.right)
        {
          x = x.parent;
          tree_rotate_left(root, x);
        }

        x.parent.color = Color::black;
        xpp.color = Color::red;
        tree_rotate_right(root, xpp);
      }
    }
    else
    {
      var y = xpp.left;

      if (y && y.color == Color::red)
      {
        x.parent.color = Color::black;
        y.color = Color::black;
        xpp.color = Color::red;
        x = xpp;
      }
      else
      {
        if (x == x.parent.left)
        {
          x = x.parent;
          tree_rotate_right(root, x);
        }

        x.parent.color = Color::black;
        xpp.color = Color::red;
        tree_rotate_left(root, xpp);
      }
    }
  }

  root.color = Color::black;
}

fn tree_balance_for_erase<K, T, Cmp, Allocator>(map<K, T, Cmp, Allocator>::Link mut * mut &root, map<K, T, Cmp, Allocator>::Link mut *z) -> void
{
  using Color = map<K, T, Cmp, Allocator>::Link::Color;

  var y = z;
  var x = z;
  var xp = z;

  if (!y.left)
    x = y.right;
  else if (!y.right)
    x = y.left;
  else
  {
    y = y.right;
    while (y.left)
      y = y.left;
    x = y.right;
  }

  if (y != z)
  {
    z.left.parent = y;
    y.left = z.left;

    if (y != z.right)
    {
      xp = y.parent;
      if (x)
        x.parent = y.parent;
      y.parent.left = x;
      y.right = z.right;
      z.right.parent = y;
    }
    else
      xp = y;

    if (z == root)
      root = y;
    else if (z.parent.left == z)
      z.parent.left = y;
    else
      z.parent.right = y;

    y.parent = z.parent;
    swap(y.color, z.color);
    y = z;
  }
  else
  {
    xp = y.parent;
    if (x)
      x.parent = y.parent;

    if (z == root)
      root = x;
    else if (z.parent.left == z)
      z.parent.left = x;
    else
      z.parent.right = x;
  }

  if (y.color == Color::black)
  {
    while (x != root && (!x || x.color == Color::black))
    {
      if (x == xp.left)
      {
        var w = xp.right;

        if (w.color == Color::red)
        {
          w.color = Color::black;
          xp.color = Color::red;
          tree_rotate_left(root, xp);
          w = xp.right;
        }

        if ((!w.left || w.left.color == Color::black) && (!w.right || w.right.color == Color::black))
        {
          w.color = Color::red;
          x = xp;
          xp = xp.parent;
        }
        else
        {
          if (!w.right || w.right.color == Color::black)
          {
            w.left.color = Color::black;
            w.color = Color::red;
            tree_rotate_right(root, w);
            w = xp.right;
          }

          w.color = xp.color;
          xp.color = Color::black;
          if (w.right)
            w.right.color = Color::black;
          tree_rotate_left(root, xp);
          break;
        }
      }
      else
      {
        var w = xp.left;

        if (w.color == Color::red)
        {
          w.color = Color::black;
          xp.color = Color::red;
          tree_rotate_right(root, xp);
          w = xp.left;
        }

        if ((!w.right || w.right.color == Color::black) && (!w.left || w.left.color == Color::black))
        {
          w.color = Color::red;
          x = xp;
          xp = xp.parent;
        }
        else
        {
          if (!w.left || w.left.color == Color::black)
          {
            w.right.color = Color::black;
            w.color = Color::red;
            tree_rotate_left(root, w);
            w = xp.left;
          }

          w.color = xp.color;
          xp.color = Color::black;
          if (w.left)
            w.left.color = Color::black;
          tree_rotate_right(root, xp);
          break;
        }
      }
    }

    if (x)
      x.color = Color::black;
  }
}

fn tree_verify<K, T, Cmp, Allocator>(map<K, T, Cmp, Allocator> &map) -> bool
{
  using Link = map<K, T, Cmp, Allocator>::Link;
  using Node = map<K, T, Cmp, Allocator>::Node;
  using Color = map<K, T, Cmp, Allocator>::Link::Color;

  if (map._len == 0 || map.begin() == map.end())
    return map._len == 0 && map.begin() == map.end() && map._leftmost == &map._root && map._root.left == &map._root;

  fn black_count(Link *first, Link *last) -> usize
  {
    var len = 0;

    for(var node = first; node != last; node = node.parent)
    {
      if (node.color == Color::black)
        ++len;
    }

    return len;
  }

  var len = black_count(map._leftmost, map._root.parent);

  for(var node = map.begin; node != map.end; ++node)
  {
    var x = node.cursor;
    var l = x.left;
    var r = x.right;

    if (x.color == Color::red && ((l && l.color == Color::red) || (r && r.color == Color::red)))
      return false;

    if (l && map.cmp(cast<Node*>(x).value.key, cast<Node*>(l).value.key))
      return false;

    if (r && map.cmp(cast<Node*>(r).value.key, cast<Node*>(x).value.key))
      return false;

    if (!l && !r && black_count(x, map._root.parent) != len)
      return false;
  }

  var leftmost = map._root.parent;

  while (leftmost.left)
    leftmost = leftmost.left;

  if (map._leftmost != leftmost)
    return false;

  var rightmost = map._root.parent;

  while (rightmost.right)
    rightmost = rightmost.right;

  if (map._root.left != rightmost)
    return false;

  return true;
}
