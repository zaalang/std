//
// std span
//

import std.stdlib : assert;
import std.range : Range;

pub concept Span<U>
{
  requires<T> (T x) { x.len; }
  requires<T> (T x) { x.data; }
  requires<T> (T x) -> U { return *x.data; }
  requires<T> (T x) -> U { return x[x.begin]; }
  requires<T> (T x) { x.end; }
}

pub fn Span<T, N>(T[N] &&array)
{
  return &(&&array);
}

pub struct span<T>
{
  pub usize len;
  pub T *data;

  #[lifetime(clone(data))]
  pub span(T *data, usize len)
    : len(len), data(data)
  {
  }

  #[lifetime(clone(beg))]
  pub span(T *beg, T *end)
    : len(end - beg), data(beg)
  {
  }

  pub fn empty(this &) -> bool
  {
    return this.len == 0;
  }

  #[lifetime(clone(this))]
  pub fn begin(this &) -> T *
  { 
    return this.data;
  }
  
  #[lifetime(clone(this))]
  pub fn end(this &) -> T *
  { 
    return this.data + this.len;
  }
  
  #[lifetime(clone(this))]
  pub fn [](this &, usize index) -> T &
  {
    assert(index < this.len);

    return &*(this.data + index);
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (usize, usize) range) -> span<T>
  {
    assert(range.0 <= range.1 && range.0 < this.len && range.1 <= this.len);

    return span(this.data + range.0, this.data + range.1);
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (usize, usize, void) range) -> span<T>
  {
    assert(range.0 <= range.1 && range.0 < this.len && range.1 + 1 <= this.len);

    return span(this.data + range.0, this.data + range.1 + 1);
  }

  #[lifetime(clone(this))]
  pub fn [](this &, T *iter)
  {
    assert(this.data <= iter && iter < this.data + this.len);

    return &*iter;
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (T*, T*) range) -> span<T>
  {
    assert(range.0 <= range.1 && this.data <= range.0 && range.1 <= this.data + this.len);

    return span(range.0, range.1);
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (T*, T*, void) range) -> span<T>
  {
    assert(range.0 <= range.1 && this.data <= range.0 && range.1 + 1 <= this.data + this.len);

    return span(range.0, range.1 + 1);
  }

  pub fn remove_prefix(this mut &, usize n) -> void
  {
    assert(n <= this.len);

    this.len -= n;
    this.data += n;
  }

  pub fn remove_suffix(this mut &, usize n) -> void
  {
    assert(n <= this.len);

    this.len -= n;
  }

  #[lifetime(clone(that))]
  pub span(mutable_span<T> &that)
    : len(that.len), data(that.data)
  {
  }

  #[lifetime(assign(this, clone(that)), depend(this))]
  pub fn =(this mut &, mutable_span<T> &that) -> span mut &
  {
    this.len = that.len;
    this.data = that.data;
    return &this;
  }

  pub span() = default;
  pub span(span &that) = default;
  pub fn =(this mut &, span &that) -> span mut & = default;
  pub ~span() = default;
}

pub struct mutable_span<T>
{
  pub usize len;
  pub T mut *data;

  #[lifetime(clone(data))]
  pub mutable_span(T mut *data, usize len)
    : len(len), data(data)
  {
  }

  #[lifetime(clone(beg))]
  pub mutable_span(T mut *beg, T mut *end)
    : len(end - beg), data(beg)
  {
  }

  pub fn empty(this &) -> bool
  {
    return this.len == 0;
  }

  #[lifetime(clone(this))]
  pub fn begin(this &&)
  {
    return this.data;
  }

  #[lifetime(clone(this))]
  pub fn end(this &&)
  {
    return this.data + this.len;
  }

  #[lifetime(clone(this))]
  pub fn [](this &&, usize index)
  {
    assert(index < this.len);

    return &*(this.data + index);
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (usize, usize) range) -> span<T>
  {
    assert(range.0 <= range.1 && range.0 <= this.len && range.1 <= this.len);

    return span(this.data + range.0, this.data + range.1);
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (usize, usize, void) range) -> span<T>
  {
    assert(range.0 <= range.1 && range.0 <= this.len && range.1 + 1 <= this.len);

    return span(this.data + range.0, this.data + range.1 + 1);
  }

  #[lifetime(clone(this))]
  pub fn [](this mut &, (usize, usize) range) -> mutable_span<T>
  {
    assert(range.0 <= range.1 && range.0 <= this.len && range.1 <= this.len);

    return mutable_span(this.data + range.0, this.data + range.1);
  }

  #[lifetime(clone(this))]
  pub fn [](this mut &, (usize, usize, void) range) -> mutable_span<T>
  {
    assert(range.0 <= range.1 && range.0 <= this.len && range.1 + 1 <= this.len);

    return mutable_span(this.data + range.0, this.data + range.1 + 1);
  }

  #[lifetime(clone(this))]
  pub fn [](this &&, T *iter)
  {
    assert(this.data <= iter && iter < this.data + this.len);

    return &*(this.data + (iter - this.data));
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (T*, T*) range) -> span<T>
  {
    assert(range.0 <= range.1 && this.data <= range.0 && range.1 <= this.data + this.len);

    return span(range.0, range.1);
  }

  #[lifetime(clone(this))]
  pub fn [](this &, (T*, T*, void) range) -> span<T>
  {
    assert(range.0 <= range.1 && this.data <= range.0 && range.1 + 1 <= this.data + this.len);

    return span(range.0, range.1 + 1);
  }

  #[lifetime(clone(this))]
  pub fn [](this mut &, (T*, T*) range) -> mutable_span<T>
  {
    assert(range.0 <= range.1 && this.data <= range.0 && range.1 <= this.data + this.len);

    return mutable_span(cast<T mut *>(range.0), cast<T mut *>(range.1));
  }

  #[lifetime(clone(this))]
  pub fn [](this mut &, (T*, T*, void) range) -> mutable_span<T>
  {
    assert(range.0 <= range.1 && this.data <= range.0 && range.1 + 1 <= this.data + this.len);

    return mutable_span(cast<T mut *>(range.0), cast<T mut *>(range.1 + 1));
  }

  pub fn remove_prefix(this mut &, usize n) -> void
  {
    assert(n <= this.len);

    this.len -= n;
    this.data += n;
  }

  pub fn remove_suffix(this mut &, usize n) -> void
  {
    assert(n <= this.len);

    this.len -= n;
  }

  pub mutable_span() = default;
  pub mutable_span(mutable_span &that) = default;
  pub fn =(this mut &, mutable_span &that) -> mutable_span mut & = default;
  pub ~mutable_span() = default;
}

pub struct moveable_span<T>
{
  pub usize len;
  pub T mut *data;

  #[lifetime(clone(data))]
  pub moveable_span(T mut *data, usize len)
    : len(len), data(data)
  {
  }

  #[lifetime(clone(beg))]
  pub moveable_span(T mut *beg, T mut *end)
    : len(end - beg), data(beg)
  {
  }

  pub fn empty(this &) -> bool
  {
    return this.len == 0;
  }

  #[lifetime(clone(this))]
  pub fn begin(this &&)
  {
    return this.data;
  }

  #[lifetime(clone(this))]
  pub fn end(this &&)
  {
    return this.data + this.len;
  }

  #[lifetime(clone(this))]
  pub fn [](this &&, usize index)
  {
    assert(index < this.len);

    return &cast<&&typeof(this)>(*(this.data + index));
  }

  #[lifetime(clone(this))]
  pub fn [](this &&, T *iter)
  {
    assert(this.data <= iter && iter < this.data + this.len);

    return &cast<&&typeof(this)>(*(this.data + (iter - this.data)));
  }

  pub moveable_span() = default;
  pub moveable_span(moveable_span &that) = default;
  pub fn =(this mut &, moveable_span &that) -> moveable_span mut & = default;
  pub ~moveable_span() = default;
}

#[lifetime(consume(span))]
pub fn move<T>(mutable_span<T> mut &span)
{
  return moveable_span(span.data, span.len);
}

#[lifetime(clone(span))]
pub fn subspan<T>(Span<T> &&span, usize offset, usize count)
{
  return span[std::min(offset, span.len) .. std::min(offset + count, span.len)];
}

pub fn read(Span<u8> mut &span, u8 mut *data, usize len) -> usize
{
  var bytes = std::min(span.len, len);

  std::memcpy(data, span.data, bytes);

  span.remove_prefix(bytes);

  return bytes;
}

pub fn write(std::mutable_span<u8> mut &span, u8 *data, usize len) -> usize
{
  var bytes = std::min(span.len, len);

  std::memcpy(span.data, data, bytes);

  span.remove_prefix(bytes);

  return bytes;
}
