//
// std range
//

import std.stdlib;
import std.iterator : Iterator, Sentinal, RandomAccessIterator;
import std.span : Span;
import std.fmt;

// NOTE:
//  Range is expected to behave like at least a multi-pass-forward range.
//  Input iterator ranges shouldn't match due to throwing operations

pub concept Range<U>
{
  requires<T> !__is_pointer<T>;
  requires<T> (T x) -> U { return *x.begin; };
  requires<T> (T x) { x.end; };
}

pub struct iterator_pair<I, J>
{
  pub I first;
  pub J second;

  pub iterator_pair(I first, J second)
    : first(first), second(second)
  {
  }

  pub iterator_pair() = default;
  pub iterator_pair(iterator_pair &&) = default;
  pub fn =(iterator_pair mut &, iterator_pair &) -> iterator_pair mut & = default;
  pub ~iterator_pair() = default;

  #[lifetime(clone(this))]
  pub fn begin(this &&)
  {
    return (&&this).first;
  }

  #[lifetime(clone(this))]
  pub fn end(this &&)
  {
    return (&&this).second;
  }

  #[lifetime(clone(this))]
  pub fn [](this &&, usize index)
    where __is_match<RandomAccessIterator, I>
  {
    return &&(*std::next((&&this).first, index));
  }
}

pub fn Range<T, N>(T[N] &&array)
{
  #if (__is_rvalue<typeof(array)>)
    return std::iterator_pair(std::move_iterator(array.begin), std::move_iterator(array.end));

  return std::iterator_pair((&&array).begin, (&&array).end);
}

pub fn Range<T = u8>(typeof("") &str) -> std::span<T>
  where __is_same<T, u8>
{
  return std::span<u8>(str.data, str.len);
}

pub fn is_range<R, T>() -> bool
{
  return __is_match<Range<T>, R>;
}

pub fn is_range<T>(var &range) -> bool
{
  return __is_match<Range<T>, typeof(range)>;
}

pub const fn is_all_ranges<Rs, T>() -> bool
{
  #for(const k = 0; k < __tuple_len<Rs>; ++k)
    if (!__is_match<Range<T>, typeof(Rs::#k)>())
      return false;

  return true;
}

#[lifetime(consume(range))]
pub fn move<T>(std::mutable_span<T> mut &range)
{
  return std::iterator_pair(std::move_iterator(range.begin), std::move_iterator(range.end));
}

#[lifetime(consume(range))]
pub fn move<I, J>(std::iterator_pair<I, J> mut &range)
{
  return std::iterator_pair(std::move_iterator(range.begin), std::move_iterator(range.end));
}

pub fn len<T>(Range<T> &&range) -> usize
{
  return std::distance(range.begin, range.end);
}

pub fn ==<T>(Range<T> &&lhs, Range<T> &&rhs) -> bool
  where requires (typeof(lhs) x, typeof(rhs) y) { *x.begin == *y.begin; }
{
  if (lhs.len != rhs.len)
    return false;

  for(var i = lhs.begin, var j = rhs.begin, var end = lhs.end; i != end; ++i, ++j)
  {
    if (!(*i == *j))
      return false;
  }

  return true;
}

pub fn <=><T>(Range<T> &&lhs, Range<T> &&rhs) -> int
  where requires (typeof(lhs) x, typeof(rhs) y) { *x.begin <=> *y.begin; }
{
  var i = lhs.begin;
  var j = rhs.begin;

  for(var endi = lhs.end, var endj = rhs.end; j != endj; ++i, ++j)
  {
    if (i == endi)
      return -1;

    if (var cmp = (*i <=> *j); cmp != 0)
      return cmp;
  }

  if (i != lhs.end)
    return +1;

  return 0;
}

pub fn fmt<T>(std::OutputStream mut &os, std::fmt_context mut &ctx, Range<T> &range) throws -> void
{
  ctx.written += std::print_to(os, "[");

  for(var k = 0, var &value : range;; ++k)
  {
    if (k != 0)
      ctx.written += std::print_to(os, ", ");

    std::fmt_to(os, ctx, value);
  }

  ctx.written += std::print_to(os, "]");
}

pub struct iota_view<I, J> : iterator_pair<iota_iterator<I>, iota_iterator<J>>
{
  pub iota_view(I beg, J end = void)
    : super(iota_iterator(beg), iota_iterator(end))
  {
  }

  pub ~iota_view() = default;

  pub struct iota_iterator<N>
  {
    N n;

    iota_iterator(N &&n)
      : n(&&n)
    {
    }

    pub iota_iterator() = default;
    pub iota_iterator(iota_iterator &&) = default;
    pub fn =(iota_iterator mut &lhs, iota_iterator &&rhs) -> iota_iterator mut & = default;
    pub ~iota_iterator() = default;

    pub fn *(iota_iterator &this)
    {
      return this.n;
    }

    pub fn ++(iota_iterator mut &this) -> iota_iterator mut &
    {
      ++this.n;

      return &this;
    }

    pub fn --(iota_iterator mut &this) -> iota_iterator mut &
      where requires (N n) { --n; }
    {
      --this.n;

      return &this;
    }

    pub fn ==<I, J>(iota_iterator<I> &lhs, iota_iterator<J> &rhs) -> bool
    {
      return lhs.n == rhs.n;
    }

    pub fn ==<I, J>(iota_iterator<I> &lhs, iota_iterator<void> &rhs) -> bool
    {
      return false;
    }
  }

  pub const fn is_bounded() -> bool
  {
    return requires (I i, J j) { j - i; };
  }

  pub fn -<I, J>(iota_iterator<I> &lhs, iota_iterator<J> &rhs) -> usize
    where requires (I i, J j) { i - j; }
  {
    return cast<usize>(lhs.n - rhs.n);
  }

  pub fn +<I>(iota_iterator<I> &lhs, usize rhs) -> iota_iterator<I>
    where requires (I i, usize j) { i + j; }
  {
    return iota_iterator<I>(lhs.n + cast<I>(rhs));
  }

  pub fn len(this &) -> usize
  {
    #std::assert(is_bounded, "unbounded");

    return cast<usize>(this.second.n - this.first.n);
  }
}

pub fn iota<T>(T &&value)
{
  return iota_view(&&value);
}

pub fn iota<T, W>(T &&value, W &&bound)
  match(T x, W y) { x == y; }
{
  return iota_view(&&value, &&bound);
}

pub struct reverse_view<I, J> : iterator_pair<reverse_iterator<I>, reverse_iterator<J>>
{
  pub reverse_view(I beg, J end)
    : super(reverse_iterator(end), reverse_iterator(beg))
  {
  }

  pub ~reverse_view() = default;

  pub struct reverse_iterator<X>
  {
    pub X base;

    reverse_iterator(X &&base)
      : base(&&base)
    {
    }

    pub reverse_iterator() = default;
    pub reverse_iterator(reverse_iterator &&) = default;
    pub fn =(reverse_iterator mut &lhs, reverse_iterator &&rhs) -> reverse_iterator mut & = default;
    pub ~reverse_iterator() = default;

    pub fn *(reverse_iterator &&this)
    {
      return &&(*std::prev(this.base));
    }

    pub fn ++(reverse_iterator mut &this) -> reverse_iterator mut &
      where requires (X mut &x) { --x; }
    {
      --this.base;

      return &this;
    }

    pub fn --(reverse_iterator mut &this) -> reverse_iterator mut &
      where requires (X mut &x) { ++x; }
    {
      ++this.base;

      return &this;
    }

    pub fn ==(reverse_iterator &lhs, X &rhs) -> bool
    {
      return lhs.base == rhs;
    }

    pub fn ==<I, J>(reverse_iterator<I> &lhs, reverse_iterator<J> &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }
  }

  pub fn -<I, J>(reverse_iterator<I> &lhs, reverse_iterator<J> &rhs) -> usize
    where requires (I i, J j) { j - i; }
  {
    return rhs.base - lhs.base;
  }

  pub fn +<I>(reverse_iterator<I> lhs, usize rhs) -> reverse_iterator<I>
    where requires (I i, usize j) { i - j; }
  {
    return reverse_iterator<I>(lhs.base - rhs);
  }
}

#[lifetime(depend(range))]
pub fn reverse<T>(Range<T> &&range)
{
  return reverse_view((&&range).begin, (&&range).end);
}

#[lifetime(depend(range))]
pub fn reverse<I, J>(zip_view<I, J> &&range)
{
  return reverse_view((&&range).begin, (&&range).begin + range.len);
}

pub struct filter_view<I, J, Pred> : iterator_pair<filter_iterator<I>, filter_iterator<J>>
{
  pub filter_view(I beg, J end, Pred &&pred)
    : super(filter_iterator(beg, end, _pred), filter_iterator(end, _pred)),
      _pred(&&pred)
  {
  }

  pub ~filter_view() = default;

  pub struct filter_iterator<X>
  {
    pub X base;

    filter_iterator(X &&base, J &&end, Pred &pred)
      : base(&&base), end(&&end), pred(&pred)
    {
      while (this.base != this.end && !this.pred(*this.base))
        ++this.base;
    }

    filter_iterator(X &&end, Pred &pred)
      : base(&&end), end(&&end), pred(&pred)
    {
    }

    pub filter_iterator() = default;
    pub filter_iterator(filter_iterator &&) = default;
    pub fn =(filter_iterator mut &lhs, filter_iterator &&rhs) -> filter_iterator mut & = default;
    pub ~filter_iterator() = default;

    pub fn *(filter_iterator &&this)
    {
      return &&(*this.base);
    }

    pub fn ++(filter_iterator mut &this) -> filter_iterator mut &
      where requires (X mut &x) { ++x; }
    {
      ++this.base;

      while (this.base != this.end && !this.pred(*this.base))
        ++this.base;

      return &this;
    }

    pub fn --(filter_iterator mut &this) -> filter_iterator mut &
      where requires (X mut &x) { --x; }
    {
      while (true)
      {
        --this.base;

        if (this.pred(*this.base))
          break;
      }

      return &this;
    }

    pub fn ==(filter_iterator &lhs, X &rhs) -> bool
    {
      return lhs.base == rhs;
    }

    pub fn ==<I, J>(filter_iterator<I> &lhs, filter_iterator<J> &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }

    J end;
    Pred &pred;
  }

  Pred _pred;
}

#[lifetime(depend(range))]
pub fn filter<T, Pred>(Range<T> &&range, Pred &&pred)
{
  return filter_view((&&range).begin, (&&range).end, &&pred);
}

pub struct transform_view<I, J, Func> : iterator_pair<transform_iterator<I>, transform_iterator<J>>
{
  pub transform_view(I beg, J end, Func &&func)
    : super(transform_iterator(beg, _func), transform_iterator(end, _func)),
      _func(&&func)
  {
  }

  pub ~transform_view() = default;

  pub struct transform_iterator<X>
  {
    pub X base;

    transform_iterator(X &&base, Func &func)
      : base(&&base), func(&func)
    {
    }

    pub transform_iterator() = default;
    pub transform_iterator(transform_iterator &&) = default;
    pub fn =(transform_iterator mut &lhs, transform_iterator &&rhs) -> transform_iterator mut & = default;
    pub ~transform_iterator() = default;

    pub fn *(transform_iterator &&this)
    {
      return &&this.func(*this.base);
    }

    pub fn ++(transform_iterator mut &this) -> transform_iterator mut &
      where requires (X mut &x) { ++x; }
    {
      ++this.base;

      return &this;
    }

    pub fn --(transform_iterator mut &this) -> transform_iterator mut &
      where requires (X mut &x) { --x; }
    {
      --this.base;

      return &this;
    }

    pub fn ==(transform_iterator &lhs, X &rhs) -> bool
    {
      return lhs.base == rhs;
    }

    pub fn ==<I, J>(transform_iterator<I> &lhs, transform_iterator<J> &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }

    Func &func;
  }

  pub fn -<I, J>(transform_iterator<I> &lhs, transform_iterator<J> &rhs) -> usize
    where requires (I i, J j) { i - j; }
  {
    return lhs.base - rhs.base;
  }

  pub fn +<I>(transform_iterator<I> lhs, usize rhs) -> transform_iterator<I>
    where requires (I i, usize j) { i + j; }
  {
    return transform_iterator<I>(lhs.base + rhs, lhs.func);
  }

  Func _func;
}

#[lifetime(depend(range))]
pub fn transform<T, Func>(Range<T> &&range, Func &&func)
{
  return transform_view((&&range).begin, (&&range).end, &&func);
}

pub struct zip_view<I, J> : iterator_pair<zip_iterator, zip_sentinal>
{
  pub zip_view(I beg, J end)
    : super(zip_iterator(beg, end), zip_sentinal())
  {
  }

  pub ~zip_view() = default;

  pub struct zip_iterator
  {
    pub I base;

    zip_iterator(I &&base, J &&end)
      : base(&&base), end(&&end)
    {
    }

    pub zip_iterator() = default;
    pub zip_iterator(zip_iterator &&) = default;
    pub fn =(zip_iterator mut &lhs, zip_iterator &&rhs) -> zip_iterator mut & = default;
    pub ~zip_iterator() = default;

    pub fn *(zip_iterator &&this)
    {
      fn deref(I && ...is)
      {
        return std::tuple((&&*is)...);
      }

      return deref(this.base...);
    }

    pub fn ++(zip_iterator mut &this) -> zip_iterator mut &
    {
      #for(var mut &i : this.base)
        ++i;

      return &this;
    }

    pub fn --(zip_iterator mut &this) -> zip_iterator mut &
      where is_random_access()
    {
      #for(var mut &i : this.base)
        --i;

      return &this;
    }

    pub fn ==(zip_iterator &lhs, zip_iterator &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }

    pub fn ==(zip_iterator &this, zip_sentinal &) -> bool
    {
      #for(const i = 0; i < __tuple_len<I>; ++i)
        if (this.base.#i == this.end.#i)
          return true;

      return false;
    }

    J end;
  }

  pub struct zip_sentinal
  {
    pub zip_sentinal() = default;
    pub zip_sentinal(zip_sentinal &&) = default;
    pub fn =(zip_sentinal mut &lhs, zip_sentinal &&rhs) -> zip_sentinal mut & = default;
    pub ~zip_sentinal() = default;
  }

  pub fn -(zip_iterator &lhs, zip_iterator &rhs) -> usize
    where is_random_access()
  {
    return lhs.base.0 - rhs.base.0;
  }

  pub fn -(zip_sentinal &lhs, zip_iterator &rhs) -> usize
    where is_random_access()
  {
    var len = rhs.end.0 - rhs.base.0;

    #for(const i = 1; i < __tuple_len<I>; ++i)
      if (var dist = rhs.end.#i - rhs.base.#i; dist < len)
        len = dist;

    return len;
  }

  pub fn -(zip_iterator lhs, usize rhs) -> zip_iterator
    where is_random_access()
  {
    #for(var mut &i : lhs.base)
      i -= rhs;

    return lhs;
  }

  pub fn +(zip_iterator lhs, usize rhs) -> zip_iterator
    where is_random_access()
  {
    #for(var mut &i : lhs.base)
      i += rhs;

    return lhs;
  }

  pub fn is_random_access() -> bool
  {
    #for(const i = 0; i < __tuple_len<I>; ++i)
      if (!__is_match<RandomAccessIterator, typeof(I::#i)>())
        return false;

    return true;
  }
}

#[lifetime(depend(ranges))]
pub fn zip(var && ...ranges)
  where is_all_ranges<typeof(ranges)>
{
  return zip_view(std::tuple(((&&ranges).begin)...), std::tuple(((&&ranges).end)...));
}

#[lifetime(depend(range))]
pub fn subrange<T, I>(Range<T> &&range, I first, Sentinal<I> last)
{
  return std::iterator_pair(first, last);
}

#[lifetime(depend(range))]
pub fn drop_n<T>(Range<T> &&range, usize n)
{
  return range.subrange(std::next((&&range).begin, n, range.end), (&&range).end);
}

#[lifetime(depend(range))]
pub fn take_n<T>(Range<T> &&range, usize n)
{
  return range.subrange((&&range).begin, std::next((&&range).begin, n, range.end));
}
