//
// std range
//

import std.stdlib;
import std.iterator : Iterator, Sentinal, RandomAccessIterator;

pub concept Range<U>
{
  requires<T> (T x) -> U { return *x.begin; };
  requires<T> (T x) { x.end; };
}

pub fn Range<T = u8>(typeof("") &str) -> std::span<T>
  where __is_same<T, u8>
{
  return std::span<u8>(str.data, str.len);
}

pub fn move<I, J>(std::iterator_pair<I, J> mut &range)
{
  return std::iterator_pair(std::move_iterator(range.begin), std::move_iterator(range.end));
}

pub fn move<T>(std::mutable_span<T> mut &range)
{
  return std::iterator_pair(std::move_iterator(range.begin), std::move_iterator(range.end));
}

pub fn distance<I>(I first, Sentinal<I> last) -> usize
{
  using S = typeof(last);

  #if (requires (I x, S y) { y - x; })
  {
    return last - first;
  }
  #else
  {
    var result = 0;

    while (first != last)
    {
      ++first;
      ++result;
    }

    return result;
  }
}

pub fn len<T>(Range<T> &range) -> usize
{
  return distance(range.begin, range.end);
}

pub fn ==<T>(Range<T> &lhs, Range<T> &rhs) -> bool
  where requires (typeof(lhs) &x, typeof(rhs) &y) { *x.begin == *y.begin; }
{
  if (lhs.len != rhs.len)
    return false;

  for(var i = lhs.begin, var j = rhs.begin, var end = lhs.end; i != end; ++i, ++j)
  {
    if (!(*i == *j))
      return false;
  }

  return true;
}

pub fn <=><T>(Range<T> &lhs, Range<T> &rhs) -> int
  where requires (typeof(lhs) &x, typeof(rhs) &y) { *x.begin <=> *y.begin; }
{
  var i = lhs.begin;
  var j = rhs.begin;

  for(var endi = lhs.end, var endj = rhs.end; j != endj; ++i, ++j)
  {
    if (i == endi)
      return -1;

    if (var cmp = (*i <=> *j); cmp != 0)
      return cmp;
  }

  if (i != lhs.end)
    return +1;

  return 0;
}
