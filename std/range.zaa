//
// std range
//

import std.stdlib;
import std.iterator : Iterator, Sentinal, RandomAccessIterator;
import std.span : Span;
import std.fmt;

// NOTE:
//  Range is expected to behave like at least a multi-pass-forward range.
//  Input iterator ranges shouldn't match due to throwing operations

pub concept Range<U>
{
  requires<T> (T x) -> U { return x[x.begin]; }
  requires<T> (T x) { x.end; }
}

#[lifetime(depend(array))]
pub fn Range<T, N>(T[N] &&array)
{
  return &(&&array);
}

pub struct range_view<R, I, J>
{
  R &&range;

  I first;
  J second;

  #[lifetime(repose(first, range), repose(second, range))]
  pub range_view(R &&range, I first, J second)
    : range(&range), first(first), second(second)
  {
  }

  pub range_view() = default;
  pub range_view(range_view &&) = default;
  pub fn =(range_view mut &, range_view &) -> range_view mut & = default;
  pub ~range_view() = default;

  #[lifetime(depend(*this))]
  pub fn begin(this &&)
  {
    return this.first;
  }

  #[lifetime(depend(*this))]
  pub fn end(this &&)
  {
    return this.second;
  }

  #[lifetime(repose(iter, this), depend(*this))]
  pub fn []<I>(this &&, I iter)
    match (typeof(this) this, I iter) { this.range[iter]; }
  {
    return &&(&&this.range)[iter];
  }
}

pub struct moveable_range_view<R, I, J>
{
  R mut &range;

  I first;
  J second;

  #[lifetime(repose(first, range), repose(second, range))]
  pub moveable_range_view(R mut &range, I first, J second)
    : range(&range), first(first), second(second)
  {
  }

  pub moveable_range_view() = default;
  pub moveable_range_view(moveable_range_view &&) = default;
  pub fn =(moveable_range_view mut &, moveable_range_view &) -> moveable_range_view mut & = default;
  pub ~moveable_range_view() = default;

  #[lifetime(depend(*this))]
  pub fn begin(this &&)
  {
    return this.first;
  }

  #[lifetime(depend(*this))]
  pub fn end(this &&)
  {
    return this.second;
  }

  #[lifetime(repose(iter, this), depend(*this))]
  pub fn []<I>(this &&, I iter)
    match (typeof(this) this, I iter) { this.range[iter]; }
  {
    return &&cast<&&typeof(this)>((&&this.range)[iter]);
  }
}

#[lifetime(consume(range))]
pub fn move<R, I, J>(range_view<R, I, J> &&range)
{
  return moveable_range_view(&mut range.range, range.begin, range.end);
}

pub fn is_range<R, T>() -> bool
{
  return __is_match<Range<T>, R>;
}

pub fn is_range<T>(var &range) -> bool
{
  return __is_match<Range<T>, typeof(range)>;
}

pub const fn is_all_ranges<Rs, T>() -> bool
{
  #for(const k = 0; k < __tuple_len<Rs>; ++k)
    if (!__is_match<Range<T>, typeof(Rs::#k)>())
      return false;

  return true;
}

pub fn empty<T>(Range<T> &&range) -> bool
{
  return range.begin == range.end;
}

pub fn len<T>(Range<T> &&range) -> usize
  where requires (typeof(range) range) { range.end - range.begin; }
{
  return std::distance(range.begin, range.end);
}

pub static fn count<T>(Range<T> &&range) -> usize
{
  #if (requires (typeof(range) range) { range.len; })
    return range.len;

  return std::distance(range.begin, range.end);
}

pub fn ==<T>(Range<T> &&lhs, Range<T> &&rhs) -> bool
  where requires (typeof(lhs) x, typeof(rhs) y) { x[x.begin] == y[y.begin]; }
{
  #if (requires (typeof(lhs) lhs, typeof(rhs) rhs) { lhs.len == rhs.len; })
    if (lhs.len != rhs.len)
      return false;

  var i = lhs.begin;
  var j = rhs.begin;

  for(var endi = lhs.end, var endj = rhs.end; j != endj; ++i, ++j)
  {
    if (i == endi)
      return false;

    if (!(lhs[i] == rhs[j]))
      return false;
  }

  if (i != lhs.end)
    return false;

  return true;
}

pub fn <=><T>(Range<T> &&lhs, Range<T> &&rhs) -> int
  where requires (typeof(lhs) x, typeof(rhs) y) { x[x.begin] <=> x[y.begin]; }
{
  var i = lhs.begin;
  var j = rhs.begin;

  for(var endi = lhs.end, var endj = rhs.end; j != endj; ++i, ++j)
  {
    if (i == endi)
      return -1;

    if (var cmp = (lhs[i] <=> rhs[j]); cmp != 0)
      return cmp;
  }

  if (i != lhs.end)
    return +1;

  return 0;
}

pub fn fmt<T>(std::OutputStream mut &os, std::fmt_context mut &ctx, Range<T> &range) throws -> void
{
  ctx.written += std::print_to(&mut os, "[");

  for(var k = 0, var &value : range;; ++k)
  {
    if (k != 0)
      ctx.written += std::print_to(&mut os, ", ");

    std::fmt_to(&mut os, &mut ctx, value);
  }

  ctx.written += std::print_to(&mut os, "]");
}

pub struct iota_view<I, J>
{
  pub iota_iterator<I> first;
  pub iota_iterator<J> second;

  pub iota_view(I beg, J end = void)
    : first(beg), second(end)
  {
  }

  pub ~iota_view() = default;

  pub struct iota_iterator<N>
  {
    N n;

    iota_iterator(N &&n)
      : n(&&n)
    {
    }

    pub iota_iterator() = default;
    pub iota_iterator(iota_iterator &&) = default;
    pub fn =(iota_iterator mut &lhs, iota_iterator &&rhs) -> iota_iterator mut & = default;
    pub ~iota_iterator() = default;

    pub fn *(iota_iterator &this)
    {
      return this.n;
    }

    pub fn ++(iota_iterator mut &this) -> iota_iterator mut &
    {
      ++this.n;

      return &this;
    }

    pub fn --(iota_iterator mut &this) -> iota_iterator mut &
      where requires (N n) { --n; }
    {
      --this.n;

      return &this;
    }

    pub fn ==<I, J>(iota_iterator<I> &lhs, iota_iterator<J> &rhs) -> bool
    {
      return lhs.n == rhs.n;
    }

    pub fn ==<I, J>(iota_iterator<I> &lhs, iota_iterator<void> &rhs) -> bool
    {
      return false;
    }
  }

  pub const fn is_bounded() -> bool
  {
    return requires (I i, J j) { j - i; };
  }

  pub fn -<I, J>(iota_iterator<I> &lhs, iota_iterator<J> &rhs) -> usize
    where requires (I i, J j) { i - j; }
  {
    return cast<usize>(lhs.n - rhs.n);
  }

  pub fn -<I>(iota_iterator<I> &lhs, usize rhs) -> iota_iterator<I>
    where requires (I i, usize j) { i - cast<I>(j); }
  {
    return iota_iterator<I>(lhs.n - cast<I>(rhs));
  }

  pub fn +<I>(iota_iterator<I> &lhs, usize rhs) -> iota_iterator<I>
    where requires (I i, usize j) { i + cast<I>(j); }
  {
    return iota_iterator<I>(lhs.n + cast<I>(rhs));
  }

  pub fn begin(this &&)
  {
    return this.first;
  }

  pub fn end(this &&)
  {
    return this.second;
  }

  pub fn [](this &&, iota_iterator<I> iter)
  {
    return iter.n;
  }
}

pub fn iota(#int value)
{
  return iota_view(value);
}

pub fn iota(#int value, #int bound)
{
  return iota_view(value, bound);
}

pub fn iota(#float value)
{
  return iota_view(value);
}

pub fn iota(#float value, #float bound)
{
  return iota_view(value, bound);
}

pub fn iota<T>(T &&value)
{
  return iota_view(&&value);
}

pub fn iota<T, W>(T &&value, W &&bound)
  match(T x, W y) { x == y; }
{
  return iota_view(&&value, &&bound);
}

pub struct reverse_view<R, I, J>
{
  R &&range;

  pub reverse_iterator<J> first;
  pub reverse_iterator<I> second;

  pub reverse_view(R &&range, I beg, J end)
    : range(&range), first(end), second(beg)
  {
  }

  pub ~reverse_view() = default;

  pub struct reverse_iterator<X>
  {
    pub X base;

    reverse_iterator(X base)
      : base(base)
    {
    }

    pub reverse_iterator() = default;
    pub reverse_iterator(reverse_iterator &&) = default;
    pub fn =(reverse_iterator mut &lhs, reverse_iterator &&rhs) -> reverse_iterator mut & = default;
    pub ~reverse_iterator() = default;

    pub fn ++(reverse_iterator mut &this) -> reverse_iterator mut &
      where requires (X mut &x) { --x; }
    {
      --this.base;

      return &this;
    }

    pub fn --(reverse_iterator mut &this) -> reverse_iterator mut &
      where requires (X mut &x) { ++x; }
    {
      ++this.base;

      return &this;
    }

    pub fn ==(reverse_iterator &lhs, X &rhs) -> bool
    {
      return lhs.base == rhs;
    }

    pub fn ==<I, J>(reverse_iterator<I> &lhs, reverse_iterator<J> &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }
  }

  pub fn -<I, J>(reverse_iterator<I> &lhs, reverse_iterator<J> &rhs) -> usize
    where requires (I i, J j) { j - i; }
  {
    return rhs.base - lhs.base;
  }

  pub fn +<I>(reverse_iterator<I> lhs, usize rhs) -> reverse_iterator<I>
    where requires (I i, usize j) { i - j; }
  {
    return reverse_iterator<I>(lhs.base - rhs);
  }

  #[lifetime(depend(*this))]
  pub fn begin(this &&)
  {
    return this.first;
  }

  #[lifetime(depend(*this))]
  pub fn end(this &&)
  {
    return this.second;
  }

  #[lifetime(depend(*this))]
  pub fn [](this &&, reverse_iterator<J> iter)
  {
    return &&(&&this.range)[std::prev(iter.base)];
  }
}

#[nodiscard]
#[lifetime(depend(range))]
pub fn reverse<T>(Range<T> &&range)
  where requires (typeof(range) range) { --range.end; }
{
  return reverse_view<typeof(range)>(&&range, range.begin, range.end);
}

#[nodiscard]
#[lifetime(depend(range))]
pub fn reverse<Rs, I, J>(zip_view<Rs, I, J> &&range)
  where requires (typeof(range) range) { --range.end; }
{
  return reverse_view<typeof(range)>(&&range, range.begin, std::next(range.begin, range.len));
}

#[nodiscard]
#[lifetime(consume(range))]
pub fn move<R, I, J>(reverse_view<R, I, J> &&range)
{
  return moveable_range_view(&mut range, range.begin, range.end);
}

pub struct filter_view<R, I, J, Pred>
{
  R &&range;
  Pred _pred;

  pub filter_iterator<I> first;
  pub filter_iterator<J> second;

  pub filter_view(R &&range, I beg, J end, Pred &&pred)
    : range(&range), _pred(&&pred), first(beg, end, range, _pred), second(end, range, _pred),
  {
  }

  pub ~filter_view() = default;

  pub struct filter_iterator<X>
  {
    pub X base;

    filter_iterator(X base, J end, R &range, Pred &pred)
      : base(base), end(end), range(&range), pred(&pred)
    {
      while (this.base != this.end && !this.pred(this.range[this.base]))
        ++this.base;
    }

    filter_iterator(X end, R &range, Pred &pred)
      : base(end), end(end), range(&range), pred(&pred)
    {
    }

    pub filter_iterator() = default;
    pub filter_iterator(filter_iterator &&) = default;
    pub fn =(filter_iterator mut &lhs, filter_iterator &&rhs) -> filter_iterator mut & = default;
    pub ~filter_iterator() = default;

    pub fn ++(filter_iterator mut &this) -> filter_iterator mut &
      where requires (X mut &x) { ++x; }
    {
      ++this.base;

      while (this.base != this.end && !this.pred(this.range[this.base]))
        ++this.base;

      return &this;
    }

    pub fn --(filter_iterator mut &this) -> filter_iterator mut &
      where requires (X mut &x) { --x; }
    {
      while (true)
      {
        --this.base;

        if (this.pred(this.range[this.base]))
          break;
      }

      return &this;
    }

    pub fn ==(filter_iterator &lhs, X &rhs) -> bool
    {
      return lhs.base == rhs;
    }

    pub fn ==<I, J>(filter_iterator<I> &lhs, filter_iterator<J> &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }

    J end;
    R &range;
    Pred &pred;
  }

  #[lifetime(depend(*this))]
  pub fn begin(this &&)
  {
    return this.first;
  }

  #[lifetime(depend(*this))]
  pub fn end(this &&)
  {
    return this.second;
  }

  #[lifetime(depend(*this))]
  pub fn [](this &&, filter_iterator<I> iter)
  {
    return &&(&&this.range)[iter.base];
  }
}

#[nodiscard]
#[lifetime(depend(range))]
pub fn filter<T, Pred>(Range<T> &&range, Pred &&pred)
{
  return filter_view<typeof(range)>(&&range, range.begin, range.end, &&pred);
}

#[nodiscard]
#[lifetime(consume(range))]
pub fn move<R, I, J, Pred>(filter_view<R, I, J, Pred> &&range)
{
  return moveable_range_view(&mut range, range.begin, range.end);
}

pub struct take_view<R, I, J>
{
  R &&range;

  pub take_iterator first;
  pub take_sentinal second;

  pub take_view(R &&range, I beg, J end, usize n)
    : range(&range), first(beg, end, n)
  {
  }

  pub ~take_view() = default;

  pub struct take_iterator
  {
    pub I base;

    take_iterator(I base, J end, usize n)
      : base(base), end(end), n(n)
    {
    }

    pub take_iterator() = default;
    pub take_iterator(take_iterator &&) = default;
    pub fn =(take_iterator mut &lhs, take_iterator &&rhs) -> take_iterator mut & = default;
    pub ~take_iterator() = default;

    pub fn ++(take_iterator mut &this) -> take_iterator mut &
    {
      --this.n;
      ++this.base;

      return &this;
    }

    pub fn ==(take_iterator &lhs, take_iterator &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }

    pub fn ==(take_iterator &this, take_sentinal &) -> bool
    {
      return this.n == 0 || this.base == this.end;
    }

    J end;
    usize n;
  }

  pub struct take_sentinal
  {
    pub take_sentinal() = default;
    pub take_sentinal(take_sentinal &&) = default;
    pub fn =(take_sentinal mut &lhs, take_sentinal &&rhs) -> take_sentinal mut & = default;
    pub ~take_sentinal() = default;
  }

  #[lifetime(depend(*this))]
  pub fn begin(this &&)
  {
    return this.first;
  }

  #[lifetime(depend(*this))]
  pub fn end(this &&)
  {
    return this.second;
  }

  #[lifetime(depend(*this))]
  pub fn [](this &&, take_iterator iter)
  {
    return &&(&&this.range)[iter.base];
  }
}

#[nodiscard]
#[lifetime(depend(range))]
pub fn take_n<T>(Range<T> &&range, usize n)
  where !__is_match<RandomAccessIterator, typeof(range.begin)>()
{
  return take_view<typeof(range)>(&&range, range.begin, range.end, n);
}

#[nodiscard]
#[lifetime(consume(range))]
pub fn move<R, I, J>(take_view<R, I, J> &&range)
{
  return moveable_range_view(&mut range, range.begin, range.end);
}

pub struct transform_view<R, I, J, Func>
{
  R &&range;

  pub transform_iterator<I> first;
  pub transform_iterator<J> second;

  pub transform_view(R &&range, I beg, J end, Func &&func)
    : range(&range), first(beg), second(end),
      _func(&&func)
  {
  }

  pub ~transform_view() = default;

  pub struct transform_iterator<X>
  {
    pub X base;

    transform_iterator(X base)
      : base(base)
    {
    }

    pub transform_iterator() = default;
    pub transform_iterator(transform_iterator &&) = default;
    pub fn =(transform_iterator mut &lhs, transform_iterator &&rhs) -> transform_iterator mut & = default;
    pub ~transform_iterator() = default;

    pub fn ++(transform_iterator mut &this) -> transform_iterator mut &
      where requires (X mut &x) { ++x; }
    {
      ++this.base;

      return &this;
    }

    pub fn --(transform_iterator mut &this) -> transform_iterator mut &
      where requires (X mut &x) { --x; }
    {
      --this.base;

      return &this;
    }

    pub fn ==(transform_iterator &lhs, X &rhs) -> bool
    {
      return lhs.base == rhs;
    }

    pub fn ==<I, J>(transform_iterator<I> &lhs, transform_iterator<J> &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }
  }

  pub fn -<I, J>(transform_iterator<I> &lhs, transform_iterator<J> &rhs) -> usize
    where requires (I i, J j) { i - j; }
  {
    return lhs.base - rhs.base;
  }

  pub fn +<I>(transform_iterator<I> lhs, usize rhs) -> transform_iterator<I>
    where requires (I i, usize j) { i + j; }
  {
    return transform_iterator<I>(lhs.base + rhs);
  }

  #[lifetime(depend(*this))]
  pub fn begin(this &&)
  {
    return this.first;
  }

  #[lifetime(depend(*this))]
  pub fn end(this &&)
  {
    return this.second;
  }

  #[lifetime(depend(*this))]
  pub fn [](this &&, transform_iterator<I> iter)
  {
    return &&this._func((&&this.range)[iter.base]);
  }

  Func _func;
}

#[nodiscard]
#[lifetime(depend(range))]
pub fn transform<T, Func>(Range<T> &&range, Func &&func)
{
  return transform_view<typeof(range)>(&&range, range.begin, range.end, &&func);
}

pub struct zip_view<Rs, I, J>
{
  Rs rs;

  pub zip_iterator first;
  pub zip_sentinal second;

  pub zip_view(Rs rs, I beg, J end)
    : rs(rs), first(beg, end)
  {
  }

  pub ~zip_view() = default;

  pub struct zip_iterator
  {
    pub I base;

    zip_iterator(I base, J end)
      : base(base), end(end)
    {
    }

    pub zip_iterator() = default;
    pub zip_iterator(zip_iterator &&) = default;
    pub fn =(zip_iterator mut &lhs, zip_iterator &&rhs) -> zip_iterator mut & = default;
    pub ~zip_iterator() = default;

    pub fn ++(zip_iterator mut &this) -> zip_iterator mut &
    {
      #for(var mut &i : this.base)
        ++i;

      return &this;
    }

    pub fn --(zip_iterator mut &this) -> zip_iterator mut &
    {
      #for(var mut &i : this.base)
        --i;

      return &this;
    }

    pub fn ==(zip_iterator &lhs, zip_iterator &rhs) -> bool
    {
      return lhs.base == rhs.base;
    }

    pub fn ==(zip_iterator &this, zip_sentinal &) -> bool
    {
      #for(const i = 0; i < __tuple_len<I>; ++i)
        if (this.base.#i == this.end.#i)
          return true;

      return false;
    }

    J end;
  }

  pub struct zip_sentinal
  {
    pub zip_sentinal() = default;
    pub zip_sentinal(zip_sentinal &&) = default;
    pub fn =(zip_sentinal mut &lhs, zip_sentinal &&rhs) -> zip_sentinal mut & = default;
    pub ~zip_sentinal() = default;
  }

  pub fn is_random_access() -> bool
  {
    #for(const i = 0; i < __tuple_len<I>; ++i)
      if (!__is_match<RandomAccessIterator, typeof(I::#i)>())
        return false;

    return true;
  }

  pub fn -(zip_iterator &lhs, zip_iterator &rhs) -> usize
    where is_random_access()
  {
    return lhs.base.0 - rhs.base.0;
  }

  pub fn -(zip_sentinal &lhs, zip_iterator &rhs) -> usize
    where is_random_access()
  {
    var len = rhs.end.0 - rhs.base.0;

    #for(const i = 1; i < __tuple_len<I>; ++i)
      if (var dist = rhs.end.#i - rhs.base.#i; dist < len)
        len = dist;

    return len;
  }

  pub fn -(zip_iterator lhs, usize rhs) -> zip_iterator
    where is_random_access()
  {
    #for(var mut &i : lhs.base)
      i -= rhs;

    return lhs;
  }

  pub fn +(zip_iterator lhs, usize rhs) -> zip_iterator
    where is_random_access()
  {
    #for(var mut &i : lhs.base)
      i += rhs;

    return lhs;
  }

  #[lifetime(depend(*this))]
  pub fn begin(this &&)
  {
    return this.first;
  }

  #[lifetime(depend(*this))]
  pub fn end(this &&)
  {
    return this.second;
  }

  #[lifetime(depend(*this))]
  pub fn [](this &&, zip_iterator iter)
  {
    fn deref(Rs && ...rs, I && ...is)
    {
      return std::tuple((&&(&&rs)[is])...);
    }

    return deref(this.rs..., iter.base...);
  }
}

#[nodiscard]
#[lifetime(depend(ranges))]
pub fn zip(var && ...ranges)
  where is_all_ranges<typeof(ranges)>
{
  return zip_view(ranges, std::tuple((ranges.begin)...), std::tuple((ranges.end)...));
}

#[nodiscard]
#[lifetime(repose(first, range), repose(last, range), depend(range))]
pub fn subrange<T, I>(Range<T> &&range, I first, Sentinal<I> last)
{
  return range_view<typeof(range)>(range, first, last);
}

#[nodiscard]
#[lifetime(repose(first, range), repose(last, range), depend(*range))]
pub fn subrange<R, I, J>(range_view<R, I, J> &&range, I first, Sentinal<I> last)
{
  return range_view<R, I, J>(range.range, first, last);
}

#[nodiscard]
#[lifetime(depend(range))]
pub fn drop_n<T>(Range<T> &&range, usize n)
{
  return subrange(&&range, std::next(range.begin, n, range.end), range.end);
}

#[nodiscard]
#[lifetime(depend(range))]
pub fn take_n<T>(Range<T> &&range, usize n)
  where __is_match<RandomAccessIterator, typeof(range.begin)>()
{
  return subrange(&&range, range.begin, std::next(range.begin, n, range.end));
}

#[lifetime(depend(*range.[]))]
pub fn front<T>(Range<T> &&range)
{
  return &&(&&range)[range.begin];
}

#[lifetime(depend(*range.[]))]
pub fn nth<Range>(Range &&range, usize index)
{
  return &&(&&range)[std::next(range.begin, index)];
}

#[lifetime(depend(*range.[]))]
pub fn []<Range>(Range &&range, usize index)
  where requires(Range range) { Range::[](range, range.begin); } && __is_match<RandomAccessIterator, typeof(range.begin)>
{
  return &&(&&range)[std::next(range.begin, index)];
}
