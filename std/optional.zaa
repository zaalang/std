//
// std.optional
//

import std.stdlib;
import std.memory;
import std.string : String;
import std.fmt;
import std.scan;

pub union optional<T, Allocator = std::allocator>
{
  pub None,
  pub Some(T),

  pub optional()
    : None()
  {
  }

  pub optional(T &&value, Allocator &allocator = Allocator())
    : Some(&&value, allocator?: allocator)
  {
  }

  pub optional<Args>(Args && ...args, Allocator &allocator = Allocator())
    match (Args args) { T(&move args..., allocator?: std::declval<Allocator>()); }
    : Some(&&args..., allocator?: allocator)
  {
  }

  pub fn =<Args>(this mut &, Args && ...args) -> optional mut &
    match (Args args) { T(&move args..., allocator?: std::declval<Allocator>()); }
  {
    this.insert(&&args...);

    return &this;
  }

  pub fn bool(this &) -> bool
  {
    return this.kind == typeof(this.kind)::Some;
  }

  pub fn is_none(this &) -> bool
  {
    return this.kind != typeof(this.kind)::Some;
  }

  pub fn is_some(this &) -> bool
  {
    return this.kind == typeof(this.kind)::Some;
  }

  #if __is_reference<T>

    #[lifetime(depend(*this))]
    pub fn value(this &&)
    {
      std::assert(this.is_some);

      return &*this.Some;
    }

    pub fn value_or<U>(this &&, U &&default) -> std::remove_reference<T>
      match (U default) { std::remove_reference<T>(default); }
    {
      return (this.is_some) ? *this.Some : std::remove_reference<T>(&&default);
    }

    #[lifetime(depend(*this))]
    pub fn unwrap(this mut &)
    {
      std::assert(this.is_some);

      return &*this.Some;
    }

    #[lifetime(depend(*this))]
    pub fn ?!(this mut &)
    {
      std::assert(this.is_some);

      return &*this.Some;
    }

    #[lifetime(depend(*this),depend(default))]
    pub fn unwrap_or(this mut &, std::remove_reference<T> &&default)
    {
      return (this.is_some) ? &*this.Some : &default;
    }

    #[lifetime(depend(*this),depend(default))]
    pub fn ??(this mut &, std::remove_reference<T> &&default)
    {
      return (this.is_some) ? *this.Some : &default;
    }

    #[lifetime(depend(*this))]
    pub fn expect(this mut &, String &msg)
    {
      if (!this.is_some)
        std::panic(msg);

      return &*this.Some;
    }

  #else

    #[lifetime(depend(this))]
    pub fn value(this &&)
    {
      std::assert(this.is_some);

      return &(&&this.Some);
    }

    pub fn value_or<U>(this &&, U &&default) -> T
      match (U default) { T(default); }
    {
      return (this.is_some) ? &&this.Some : T(&&default);
    }

    #[lifetime(consume(this))]
    pub fn unwrap(this mut &) -> T
    {
      std::assert(this.is_some);

      return &move this.Some;
    }

    #[lifetime(consume(this))]
    pub fn ?!(this mut &) -> T
    {
      std::assert(this.is_some);

      return &move this.Some;
    }

    #[lifetime(consume(this))]
    pub fn unwrap_or<U>(this mut &, U &&default) -> T
      match (U default) { T(default); }
    {
      return (this.is_some) ? &move this.Some : T(&&default);
    }

    #[lifetime(consume(this))]
    pub fn ??<U>(this mut &, U &&default) -> T
      match (U default) { T(default); }
    {
      return (this.is_some) ? &move this.Some : T(&&default);
    }

    #[lifetime(consume(this))]
    pub fn expect(this mut &, String &msg) -> T
    {
      if (!this.is_some)
        std::panic(msg);

      return &move this.Some;
    }

  #end

  pub fn insert<Args>(this mut &, Args && ...args, Allocator &allocator = Allocator())
    match (Args args) { T(&move args..., allocator?: std::declval<Allocator>()); }
  {
    optional::~optional(&mut this);
    new<optional>(&this)(&&args..., allocator?: allocator);
  }

  pub fn emplace<Args>(this mut &, Args && ...args, Allocator &allocator = Allocator()) -> T mut &
    match (Args args) { T(&move args..., allocator?: std::declval<Allocator>()); }
  {
    insert(&mut this, &&args..., allocator?: allocator);

    return &this.Some;
  }

  #[lifetime(launder(this))]
  pub fn clear(this mut &) -> void
  {
    optional::~optional(&mut this);
    new<optional>(&this)();
  }

  pub optional<U>(optional<U> &&other, Allocator &allocator = Allocator())
    match (typeof(other) other) { T((&move other).value, allocator?: std::declval<Allocator>()); }
  {
    switch (other)
    {
      case Some:
        new<optional>(&this)((&&other).value, allocator?: allocator);
    }
  }

  pub fn =<U>(this mut &, optional<U> &&other) -> optional mut &
    match (typeof(other) other) { T((&move other).value, allocator?: std::declval<Allocator>()); }
  {
    optional::~optional(&mut this);

    switch (other)
    {
      case Some:
        new<optional>(&this)((&&other).value, allocator?: Allocator());
    }

    return &this;
  }

  pub optional(optional &&, Allocator &allocator = Allocator()) = default;
  pub fn =(optional mut &, optional &&) -> optional mut & = default;
  pub ~optional() = default;
}

pub fn fmt<T>(std::OutputStream mut &os, std::fmt_context mut &ctx, std::optional<T> &optional) throws -> void
{
  switch (optional)
  {
    case Some[v]:
      ctx.written += std::format_to(&mut os, "Some({})", optional.value);

    case None:
      ctx.written += std::format_to(&mut os, "None");
  }
}

pub fn scan<T>(std::string_view is, std::scan_context mut &ctx, std::optional<T> mut &optional) -> void
{
  var v = T();

  std::scan_to(is, &mut ctx, &mut v);

  if (!ctx.error)
    optional = v;
}

pub fn transform<T, Func>(std::optional<T> &&optional, Func &&func) -> std::optional<typeof(func(&&optional.value))>
{
  switch (optional)
  {
    case Some[v]:
      return func((&&optional).value);
  }

  return None;
}
