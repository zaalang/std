//
// std.optional
//

import std.stdlib;
import std.memory;
import std.string : String;
import std.fmt;
import std.scan;

pub union optional<T, Allocator = std::allocator>
{
  pub None,
  pub Some(T),

  pub optional()
    : None()
  {
  }

  pub optional(T &&value, Allocator &allocator = Allocator())
    : Some(&&value, allocator?: allocator)
  {
  }

  pub optional<Args>(Args && ...args, Allocator &allocator = Allocator())
    match (Args args) { T(args..., allocator?: std::declval<Allocator>()); }
    : Some(&&args..., allocator?: allocator)
  {
  }

  pub fn =<Args>(this mut &, Args && ...args) -> optional mut &
    match (Args args) { T(args..., allocator?: std::declval<Allocator>()); }
  {
    this.insert(&&args...);

    return &this;
  }

  pub fn bool(this &) -> bool
  {
    return this.kind == typeof(this.kind)::Some;
  }

  pub fn is_none(this &) -> bool
  {
    return this.kind != typeof(this.kind)::Some;
  }

  pub fn is_some(this &) -> bool
  {
    return this.kind == typeof(this.kind)::Some;
  }

  pub fn value(this &&)
  {
    std::assert(this.is_some);

    return &(&&this.Some);
  }

  pub fn value_or<U>(this &&, U &&default) -> T
    match (U default) { T(default); }
  {
    return (this.is_some) ? &&this.Some : T(&&default);
  }

  #[lifetime(consume(this))]
  pub fn unwrap(this mut &) -> T
  {
    std::assert(this.is_some);

    return std::move(this.Some);
  }

  #[lifetime(consume(this))]
  pub fn ?!(this mut &) -> T
  {
    std::assert(this.is_some);

    return std::move(this.Some);
  }

  #[lifetime(consume(this))]
  pub fn unwrap_or<U>(this mut &, U &&default) -> T
    match (U default) { T(default); }
  {
    return (this.is_some) ? std::move(this.Some) : T(&&default);
  }

  #[lifetime(consume(this))]
  pub fn ??<U>(this mut &, U &&default) -> T
    match (U default) { T(default); }
  {
    return (this.is_some) ? std::move(this.Some) : T(&&default);
  }

  #[lifetime(consume(this))]
  pub fn expect(this mut &, String &msg) -> T
  {
    if (!this.is_some)
      std::panic(msg);

    return std::move(this.Some);
  }

  pub fn insert<Args>(this mut &, Args && ...args, Allocator &allocator = Allocator())
    match (Args args) { T(args..., allocator?: std::declval<Allocator>()); }
  {
    optional::~optional(this);
    new<optional>(&this)(&&args..., allocator?: allocator);
  }

  pub fn clear(this mut &)
  {
    optional::~optional(this);
    new<optional>(&this)();
  }

  pub optional(optional &&, Allocator &allocator = Allocator()) = default;
  pub fn =(optional mut &, optional &&) -> optional mut & = default;
  pub ~optional() = default;
}

pub fn fmt<T>(std::OutputStream mut &os, std::fmt_context mut &ctx, std::optional<T> &optional) throws -> void
{
  switch (optional)
  {
    case Some[v]:
      ctx.written += std::format_to(os, "Some({})", v);

    case None:
      ctx.written += std::format_to(os, "None");
  }
}

pub fn scan<T>(std::string_view is, std::scan_context mut &ctx, std::optional<T> mut &optional) -> void
{
  var v = T();

  std::scan_to(is, ctx, v);

  if (!ctx.error)
    optional = v;
}
